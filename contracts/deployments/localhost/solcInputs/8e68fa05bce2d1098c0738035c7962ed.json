{
  "language": "Solidity",
  "sources": {
    "@kleros/erc-792/contracts/erc-1497/IEvidence.sol": {
      "content": "pragma solidity ^0.5;\n\nimport \"../IArbitrator.sol\";\n\n/** @title IEvidence\n *  ERC-1497: Evidence Standard\n */\ninterface IEvidence {\n\n    /** @dev To be emitted when meta-evidence is submitted.\n     *  @param _metaEvidenceID Unique identifier of meta-evidence.\n     *  @param _evidence A link to the meta-evidence JSON.\n     */\n    event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n\n    /** @dev To be raised when evidence is submitted. Should point to the resource (evidences are not to be stored on chain due to gas considerations).\n     *  @param _arbitrator The arbitrator of the contract.\n     *  @param _evidenceGroupID Unique identifier of the evidence group the evidence belongs to.\n     *  @param _party The address of the party submiting the evidence. Note that 0x0 refers to evidence not submitted by any party.\n     *  @param _evidence A URI to the evidence JSON file whose name should be its keccak256 hash followed by .json.\n     */\n    event Evidence(IArbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence);\n\n    /** @dev To be emitted when a dispute is created to link the correct meta-evidence to the disputeID.\n     *  @param _arbitrator The arbitrator of the contract.\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\n     *  @param _metaEvidenceID Unique identifier of meta-evidence.\n     *  @param _evidenceGroupID Unique identifier of the evidence group that is linked to this dispute.\n     */\n    event Dispute(IArbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\n\n}\n"
    },
    "@kleros/erc-792/contracts/IArbitrable.sol": {
      "content": "/**\n *  @title IArbitrable\n *  @author Enrique Piqueras - <enrique@kleros.io>\n */\n\npragma solidity ^0.5;\n\nimport \"./IArbitrator.sol\";\n\n/** @title IArbitrable\n *  Arbitrable interface.\n *  When developing arbitrable contracts, we need to:\n *  -Define the action taken when a ruling is received by the contract.\n *  -Allow dispute creation. For this a function must call arbitrator.createDispute.value(_fee)(_choices,_extraData);\n */\ninterface IArbitrable {\n\n    /** @dev To be raised when a ruling is given.\n     *  @param _arbitrator The arbitrator giving the ruling.\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\n     *  @param _ruling The ruling which was given.\n     */\n    event Ruling(IArbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n\n    /** @dev Give a ruling for a dispute. Must be called by the arbitrator.\n     *  The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\n     *  @param _disputeID ID of the dispute in the Arbitrator contract.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Not able/wanting to make a decision\".\n     */\n    function rule(uint _disputeID, uint _ruling) external;\n}\n"
    },
    "@kleros/erc-792/contracts/IArbitrator.sol": {
      "content": "/**\n *  @title Arbitrator\n *  @author Cl√©ment Lesaege - <clement@lesaege.com>\n */\n\npragma solidity ^0.5;\n\nimport \"./IArbitrable.sol\";\n\n/** @title Arbitrator\n *  Arbitrator abstract contract.\n *  When developing arbitrator contracts we need to:\n *  -Define the functions for dispute creation (createDispute) and appeal (appeal). Don't forget to store the arbitrated contract and the disputeID (which should be unique, may nbDisputes).\n *  -Define the functions for cost display (arbitrationCost and appealCost).\n *  -Allow giving rulings. For this a function must call arbitrable.rule(disputeID, ruling).\n */\ninterface IArbitrator {\n\n    enum DisputeStatus {Waiting, Appealable, Solved}\n\n\n    /** @dev To be emitted when a dispute is created.\n     *  @param _disputeID ID of the dispute.\n     *  @param _arbitrable The contract which created the dispute.\n     */\n    event DisputeCreation(uint indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /** @dev To be emitted when a dispute can be appealed.\n     *  @param _disputeID ID of the dispute.\n     */\n    event AppealPossible(uint indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /** @dev To be emitted when the current ruling is appealed.\n     *  @param _disputeID ID of the dispute.\n     *  @param _arbitrable The contract which created the dispute.\n     */\n    event AppealDecision(uint indexed _disputeID, IArbitrable indexed _arbitrable);\n\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\n     *  Must be paid at least arbitrationCost(_extraData).\n     *  @param _choices Amount of choices the arbitrator can make in this dispute.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint _choices, bytes calldata _extraData) external payable returns(uint disputeID);\n\n    /** @dev Compute the cost of arbitration. It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return cost Amount to be paid.\n     */\n    function arbitrationCost(bytes calldata _extraData) external view returns(uint cost);\n\n    /** @dev Appeal a ruling. Note that it has to be called before the arbitrator contract calls rule.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Can be used to give extra info on the appeal.\n     */\n    function appeal(uint _disputeID, bytes calldata _extraData) external payable;\n\n    /** @dev Compute the cost of appeal. It is recommended not to increase it often, as it can be higly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return cost Amount to be paid.\n     */\n    function appealCost(uint _disputeID, bytes calldata _extraData) external view returns(uint cost);\n\n    /** @dev Compute the start and end of the dispute's current or next appeal period, if possible. If not known or appeal is impossible: should return (0, 0).\n     *  @param _disputeID ID of the dispute.\n     *  @return The start and end of the period.\n     */\n    function appealPeriod(uint _disputeID) external view returns(uint start, uint end);\n\n    /** @dev Return the status of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return status The status of the dispute.\n     */\n    function disputeStatus(uint _disputeID) external view returns(DisputeStatus status);\n\n    /** @dev Return the current ruling of a dispute. This is useful for parties to know if they should appeal.\n     *  @param _disputeID ID of the dispute.\n     *  @return ruling The ruling which has been given or the one which will be given if there is no appeal.\n     */\n    function currentRuling(uint _disputeID) external view returns(uint ruling);\n\n}\n"
    },
    "contracts/BatchWithdraw.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\nimport { GeneralizedTCR } from \"./GeneralizedTCR.sol\";\n\n/**\n *  @title BatchWithdraw\n *  Withdraw fees and rewards from contributions to disputes rounds in batches.\n */\ncontract BatchWithdraw {\n\n    /** @dev Withdraws rewards and reimbursements of multiple rounds at once. This function is O(n) where n is the number of rounds. This could exceed gas limits, therefore this function should be used only as a utility and not be relied upon by other contracts.\n     *  @param _address The address of the GTCR.\n     *  @param _contributor The address that made contributions to the request.\n     *  @param _itemID The ID of the item with funds to be withdrawn.\n     *  @param _request The request from which to withdraw contributions.\n     *  @param _cursor The round from where to start withdrawing.\n     *  @param _count The number of rounds to iterate. If set to 0 or a value larger than the number of rounds, iterates until the last round.\n     */\n    function batchRoundWithdraw(\n        address _address,\n        address payable _contributor,\n        bytes32 _itemID,\n        uint _request,\n        uint _cursor,\n        uint _count\n    ) public {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        (,,,,,uint numberOfRounds,,,,) = gtcr.getRequestInfo(_itemID, _request);\n        for (uint i = _cursor; i < numberOfRounds && (_count == 0 || i < _count); i++)\n            gtcr.withdrawFeesAndRewards(_contributor, _itemID, _request, i);\n    }\n\n    /** @dev Withdraws rewards and reimbursements of multiple requests at once. This function is O(n*m) where n is the number of requests and m is the number of rounds to withdraw per request. This could exceed gas limits, therefore this function should be used only as a utility and not be relied upon by other contracts.\n     *  @param _address The address of the GTCR.\n     *  @param _contributor The address that made contributions to the request.\n     *  @param _itemID The ID of the item with funds to be withdrawn.\n     *  @param _cursor The request from which to start withdrawing.\n     *  @param _count The number of requests to iterate. If set to 0 or a value larger than the number of request, iterates until the last request.\n     *  @param _roundCursor The round of each request from where to start withdrawing.\n     *  @param _roundCount The number of rounds to iterate on each request. If set to 0 or a value larger than the number of rounds a request has, iteration for that request will stop at the last round.\n     */\n    function batchRequestWithdraw(\n        address _address,\n        address payable _contributor,\n        bytes32 _itemID,\n        uint _cursor,\n        uint _count,\n        uint _roundCursor,\n        uint _roundCount\n    ) external {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        (\n            ,\n            ,\n            uint numberOfRequests\n        ) = gtcr.getItemInfo(_itemID);\n        for (uint i = _cursor; i < numberOfRequests && (_count == 0 || i < _count); i++)\n            batchRoundWithdraw(_address, _contributor, _itemID, i, _roundCursor, _roundCount);\n    }\n}\n"
    },
    "contracts/GeneralizedTCR.sol": {
      "content": "/**\n *  @authors: [@unknownunknown1, @mtsalenc]\n *  @reviewers: [@clesaege*, @ferittuncer, @satello*, @remedcu, @fnanni-0, @shalzz, @MerlinEgalite]\n *  @auditors: []\n *  @bounties: [{ link: https://github.com/kleros/tcr/issues/20, maxPayout: 25 ETH }]\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\nimport { IArbitrable, IArbitrator } from \"@kleros/erc-792/contracts/IArbitrator.sol\";\nimport { IEvidence } from \"@kleros/erc-792/contracts/erc-1497/IEvidence.sol\";\nimport { CappedMath } from \"./utils/CappedMath.sol\";\n\n/* solium-disable max-len */\n/* solium-disable security/no-block-members */\n/* solium-disable security/no-send */ // It is the user responsibility to accept ETH.\n\n/**\n *  @title GeneralizedTCR\n *  This contract is a curated registry for any types of items. Just like a TCR contract it features the request-challenge protocol and appeal fees crowdfunding.\n */\ncontract GeneralizedTCR is IArbitrable, IEvidence {\n    using CappedMath for uint;\n\n    /* Enums */\n\n    enum Status {\n        Absent, // The item is not in the registry.\n        Registered, // The item is in the registry.\n        RegistrationRequested, // The item has a request to be added to the registry.\n        ClearingRequested // The item has a request to be removed from the registry.\n    }\n\n    enum Party {\n        None, // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\n        Requester, // Party that made the request to change a status.\n        Challenger // Party that challenges the request to change a status.\n    }\n\n    /* Structs */\n\n    struct Item {\n        bytes data; // The data describing the item.\n        Status status; // The current status of the item.\n        Request[] requests; // List of status change requests made for the item in the form requests[requestID].\n    }\n\n    // Arrays with 3 elements map with the Party enum for better readability:\n    // - 0: is unused, matches `Party.None`.\n    // - 1: for `Party.Requester`.\n    // - 2: for `Party.Challenger`.\n    struct Request {\n        bool disputed; // True if a dispute was raised.\n        uint disputeID; // ID of the dispute, if any.\n        uint submissionTime; // Time when the request was made. Used to track when the challenge period ends.\n        bool resolved; // True if the request was executed and/or any raised disputes were resolved.\n        address payable[3] parties; // Address of requester and challenger, if any, in the form parties[party].\n        Round[] rounds; // Tracks each round of a dispute in the form rounds[roundID].\n        Party ruling; // The final ruling given, if any.\n        IArbitrator arbitrator; // The arbitrator trusted to solve disputes for this request.\n        bytes arbitratorExtraData; // The extra data for the trusted arbitrator of this request.\n        uint metaEvidenceID; // The meta evidence to be used in a dispute for this case.\n    }\n\n    struct Round {\n        uint[3] amountPaid; // Tracks the sum paid for each Party in this round. Includes arbitration fees, fee stakes and deposits.\n        bool[3] hasPaid; // True if the Party has fully paid its fee in this round.\n        uint feeRewards; // Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\n        mapping(address => uint[3]) contributions; // Maps contributors to their contributions for each side in the form contributions[address][party].\n    }\n\n    /* Storage */\n\n    IArbitrator public arbitrator; // The arbitrator contract.\n    bytes public arbitratorExtraData; // Extra data for the arbitrator contract.\n\n    uint RULING_OPTIONS = 2; // The amount of non 0 choices the arbitrator can give.\n\n    address public governor; // The address that can make changes to the parameters of the contract.\n    uint public submissionBaseDeposit; // The base deposit to submit an item.\n    uint public removalBaseDeposit; // The base deposit to remove an item.\n    uint public submissionChallengeBaseDeposit; // The base deposit to challenge a submission.\n    uint public removalChallengeBaseDeposit; // The base deposit to challenge a removal request.\n    uint public challengePeriodDuration; // The time after which a request becomes executable if not challenged.\n    uint public metaEvidenceUpdates; // The number of times the meta evidence has been updated. Used to track the latest meta evidence ID.\n\n    // Multipliers are in basis points.\n    uint public winnerStakeMultiplier; // Multiplier for calculating the fee stake paid by the party that won the previous round.\n    uint public loserStakeMultiplier; // Multiplier for calculating the fee stake paid by the party that lost the previous round.\n    uint public sharedStakeMultiplier; // Multiplier for calculating the fee stake that must be paid in the case where arbitrator refused to arbitrate.\n    uint public constant MULTIPLIER_DIVISOR = 10000; // Divisor parameter for multipliers.\n\n    bytes32[] public itemList; // List of IDs of all submitted items.\n    mapping(bytes32 => Item) public items; // Maps the item ID to its data in the form items[_itemID].\n    mapping(address => mapping(uint => bytes32)) public arbitratorDisputeIDToItem;  // Maps a dispute ID to the ID of the item with the disputed request in the form arbitratorDisputeIDToItem[arbitrator][disputeID].\n    mapping(bytes32 => uint) public itemIDtoIndex; // Maps an item's ID to its position in the list in the form itemIDtoIndex[itemID].\n\n     /* Modifiers */\n\n    modifier onlyGovernor {require(msg.sender == governor, \"The caller must be the governor.\"); _;}\n\n    /* Events */\n\n    /**\n     *  @dev Emitted when a party makes a request, raises a dispute or when a request is resolved.\n     *  @param _itemID The ID of the affected item.\n     *  @param _requestIndex The index of the request.\n     *  @param _roundIndex The index of the round.\n     *  @param _disputed Whether the request is disputed.\n     *  @param _resolved Whether the request is executed.\n     */\n    event ItemStatusChange(\n      bytes32 indexed _itemID,\n      uint indexed _requestIndex,\n      uint indexed _roundIndex,\n      bool _disputed,\n      bool _resolved\n    );\n\n    /**\n     *  @dev Emitted when someone submits an item for the first time.\n     *  @param _itemID The ID of the new item.\n     *  @param _submitter The address of the requester.\n     *  @param _evidenceGroupID Unique identifier of the evidence group the evidence belongs to.\n     *  @param _data The item data.\n     */\n    event ItemSubmitted(\n      bytes32 indexed _itemID,\n      address indexed _submitter,\n      uint indexed _evidenceGroupID,\n      bytes _data\n    );\n\n    /**\n     *  @dev Emitted when someone submits a request.\n     *  @param _itemID The ID of the affected item.\n     *  @param _requestIndex The index of the latest request.\n     *  @param _requestType Whether it is a registration or a removal request.\n     */\n    event RequestSubmitted(\n      bytes32 indexed _itemID,\n      uint indexed _requestIndex,\n      Status indexed _requestType\n    );\n\n    /**\n     *  @dev Emitted when someone submits a request. This is useful to quickly find an item and request from an evidence event and vice-versa.\n     *  @param _itemID The ID of the affected item.\n     *  @param _requestIndex The index of the latest request.\n     *  @param _evidenceGroupID The evidence group ID used for this request.\n     */\n    event RequestEvidenceGroupID(\n      bytes32 indexed _itemID,\n      uint indexed _requestIndex,\n      uint indexed _evidenceGroupID\n    );\n\n    /**\n     *  @dev Emitted when a party contributes to an appeal.\n     *  @param _itemID The ID of the item.\n     *  @param _contributor The address making the contribution.\n     *  @param _request The index of the request.\n     *  @param _round The index of the round receiving the contribution.\n     *  @param _amount The amount of the contribution.\n     *  @param _side The party receiving the contribution.\n     */\n    event AppealContribution(\n        bytes32 indexed _itemID,\n        address indexed _contributor,\n        uint indexed _request,\n        uint _round,\n        uint _amount,\n        Party _side\n    );\n\n    /** @dev Emitted when one of the parties successfully paid its appeal fees.\n     *  @param _itemID The ID of the item.\n     *  @param _request The index of the request.\n     *  @param _round The index of the round.\n     *  @param _side The side that is fully funded.\n     */\n    event HasPaidAppealFee(\n      bytes32 indexed _itemID,\n      uint indexed _request,\n      uint indexed _round,\n      Party _side\n    );\n\n    /** @dev Emitted when the address of the connected TCR is set. The connected TCR is an instance of the Generalized TCR contract where each item is the address of a TCR related to this one.\n     *  @param _connectedTCR The address of the connected TCR.\n     */\n    event ConnectedTCRSet(address indexed _connectedTCR);\n\n    /**\n     *  @dev Deploy the arbitrable curated registry.\n     *  @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     *  @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     *  @param _connectedTCR The address of the TCR that stores related TCR addresses. This parameter can be left empty.\n     *  @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     *  @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     *  @param _governor The trusted governor of this contract.\n     *  @param _submissionBaseDeposit The base deposit to submit an item.\n     *  @param _removalBaseDeposit The base deposit to remove an item.\n     *  @param _submissionChallengeBaseDeposit The base deposit to challenge a submission.\n     *  @param _removalChallengeBaseDeposit The base deposit to challenge a removal request.\n     *  @param _challengePeriodDuration The time in seconds parties have to challenge a request.\n     *  @param _stakeMultipliers Multipliers of the arbitration cost in basis points (see MULTIPLIER_DIVISOR) as follows:\n     *  - The multiplier applied to each party's fee stake for a round when there is no winner/loser in the previous round (e.g. when the arbitrator refused to arbitrate).\n     *  - The multiplier applied to the winner's fee stake for the subsequent round.\n     *  - The multiplier applied to the loser's fee stake for the subsequent round.\n     */\n    constructor(\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        address _connectedTCR,\n        string memory _registrationMetaEvidence,\n        string memory _clearingMetaEvidence,\n        address _governor,\n        uint _submissionBaseDeposit,\n        uint _removalBaseDeposit,\n        uint _submissionChallengeBaseDeposit,\n        uint _removalChallengeBaseDeposit,\n        uint _challengePeriodDuration,\n        uint[3] memory _stakeMultipliers\n    ) public {\n        emit MetaEvidence(0, _registrationMetaEvidence);\n        emit MetaEvidence(1, _clearingMetaEvidence);\n        emit ConnectedTCRSet(_connectedTCR);\n\n        arbitrator = _arbitrator;\n        arbitratorExtraData = _arbitratorExtraData;\n        governor = _governor;\n        submissionBaseDeposit = _submissionBaseDeposit;\n        removalBaseDeposit = _removalBaseDeposit;\n        submissionChallengeBaseDeposit = _submissionChallengeBaseDeposit;\n        removalChallengeBaseDeposit = _removalChallengeBaseDeposit;\n        challengePeriodDuration = _challengePeriodDuration;\n        sharedStakeMultiplier = _stakeMultipliers[0];\n        winnerStakeMultiplier = _stakeMultipliers[1];\n        loserStakeMultiplier = _stakeMultipliers[2];\n    }\n\n    /* External and Public */\n\n    // ************************ //\n    // *       Requests       * //\n    // ************************ //\n\n    /** @dev Submit a request to register an item. Accepts enough ETH to cover the deposit, reimburses the rest.\n     *  @param _item The data describing the item.\n     */\n    function addItem(bytes calldata _item) external payable {\n        bytes32 itemID = keccak256(_item);\n        require(items[itemID].status == Status.Absent, \"Item must be absent to be added.\");\n        requestStatusChange(_item, submissionBaseDeposit);\n    }\n\n    /** @dev Submit a request to remove an item from the list. Accepts enough ETH to cover the deposit, reimburses the rest.\n     *  @param _itemID The ID of the item to remove.\n     *  @param _evidence A link to an evidence using its URI. Ignored if not provided.\n     */\n    function removeItem(bytes32 _itemID,  string calldata _evidence) external payable {\n        require(items[_itemID].status == Status.Registered, \"Item must be registered to be removed.\");\n        Item storage item = items[_itemID];\n\n        // Emit evidence if it was provided.\n        if (bytes(_evidence).length > 0) {\n            // Using `length` instead of `length - 1` because a new request will be added on requestStatusChange().\n            uint requestIndex = item.requests.length;\n            uint evidenceGroupID = uint(keccak256(abi.encodePacked(_itemID, requestIndex)));\n\n            emit Evidence(arbitrator, evidenceGroupID, msg.sender, _evidence);\n        }\n\n        requestStatusChange(item.data, removalBaseDeposit);\n    }\n\n    /** @dev Challenges the request of the item. Accepts enough ETH to cover the deposit, reimburses the rest.\n     *  @param _itemID The ID of the item which request to challenge.\n     *  @param _evidence A link to an evidence using its URI. Ignored if not provided.\n     */\n    function challengeRequest(bytes32 _itemID, string calldata _evidence) external payable {\n        Item storage item = items[_itemID];\n\n        require(\n            item.status == Status.RegistrationRequested || item.status == Status.ClearingRequested,\n            \"The item must have a pending request.\"\n        );\n\n        Request storage request = item.requests[item.requests.length - 1];\n        require(now - request.submissionTime <= challengePeriodDuration, \"Challenges must occur during the challenge period.\");\n        require(!request.disputed, \"The request should not have already been disputed.\");\n\n        request.parties[uint(Party.Challenger)] = msg.sender;\n\n        Round storage round = request.rounds[0];\n        uint arbitrationCost = request.arbitrator.arbitrationCost(request.arbitratorExtraData);\n        uint challengerBaseDeposit = item.status == Status.RegistrationRequested\n            ? submissionChallengeBaseDeposit\n            : removalChallengeBaseDeposit;\n        uint totalCost = arbitrationCost.addCap(challengerBaseDeposit);\n        contribute(round, Party.Challenger, msg.sender, msg.value, totalCost);\n        require(round.amountPaid[uint(Party.Challenger)] >= totalCost, \"You must fully fund your side.\");\n        round.hasPaid[uint(Party.Challenger)] = true;\n\n        // Raise a dispute.\n        request.disputeID = request.arbitrator.createDispute.value(arbitrationCost)(RULING_OPTIONS, request.arbitratorExtraData);\n        arbitratorDisputeIDToItem[address(request.arbitrator)][request.disputeID] = _itemID;\n        request.disputed = true;\n        request.rounds.length++;\n        round.feeRewards = round.feeRewards.subCap(arbitrationCost);\n\n        uint evidenceGroupID = uint(keccak256(abi.encodePacked(_itemID, item.requests.length - 1)));\n        emit Dispute(\n            request.arbitrator,\n            request.disputeID,\n            request.metaEvidenceID,\n            evidenceGroupID\n        );\n\n        if (bytes(_evidence).length > 0) {\n            emit Evidence(request.arbitrator, evidenceGroupID, msg.sender, _evidence);\n        }\n    }\n\n    /** @dev Takes up to the total amount required to fund a side of an appeal. Reimburses the rest. Creates an appeal if both sides are fully funded.\n     *  @param _itemID The ID of the item which request to fund.\n     *  @param _side The recipient of the contribution.\n     */\n    function fundAppeal(bytes32 _itemID, Party _side) external payable {\n        require(_side == Party.Requester || _side == Party.Challenger, \"Invalid side.\");\n        require(\n            items[_itemID].status == Status.RegistrationRequested || items[_itemID].status == Status.ClearingRequested,\n            \"The item must have a pending request.\"\n        );\n        Request storage request = items[_itemID].requests[items[_itemID].requests.length - 1];\n        require(request.disputed, \"A dispute must have been raised to fund an appeal.\");\n        (uint appealPeriodStart, uint appealPeriodEnd) = request.arbitrator.appealPeriod(request.disputeID);\n        require(\n            now >= appealPeriodStart && now < appealPeriodEnd,\n            \"Contributions must be made within the appeal period.\"\n        );\n\n        /* solium-disable indentation */\n        uint multiplier;\n        {\n            Party winner = Party(request.arbitrator.currentRuling(request.disputeID));\n            Party loser;\n            if (winner == Party.Requester)\n                loser = Party.Challenger;\n            else if (winner == Party.Challenger)\n                loser = Party.Requester;\n            require(_side != loser || (now-appealPeriodStart < (appealPeriodEnd-appealPeriodStart)/2), \"The loser must contribute during the first half of the appeal period.\");\n\n\n            if (_side == winner)\n                multiplier = winnerStakeMultiplier;\n            else if (_side == loser)\n                multiplier = loserStakeMultiplier;\n            else\n                multiplier = sharedStakeMultiplier;\n        }\n        /* solium-enable indentation */\n\n        Round storage round = request.rounds[request.rounds.length - 1];\n        uint appealCost = request.arbitrator.appealCost(request.disputeID, request.arbitratorExtraData);\n        uint totalCost = appealCost.addCap((appealCost.mulCap(multiplier)) / MULTIPLIER_DIVISOR);\n        uint contribution = contribute(round, _side, msg.sender, msg.value, totalCost);\n\n        emit AppealContribution(\n            _itemID,\n            msg.sender,\n            items[_itemID].requests.length - 1,\n            request.rounds.length - 1,\n            contribution,\n            _side\n        );\n\n        if (round.amountPaid[uint(_side)] >= totalCost) {\n            round.hasPaid[uint(_side)] = true;\n            emit HasPaidAppealFee(_itemID, items[_itemID].requests.length - 1, request.rounds.length - 1, _side);\n        }\n\n        // Raise appeal if both sides are fully funded.\n        if (round.hasPaid[uint(Party.Challenger)] && round.hasPaid[uint(Party.Requester)]) {\n            request.arbitrator.appeal.value(appealCost)(request.disputeID, request.arbitratorExtraData);\n            request.rounds.length++;\n            round.feeRewards = round.feeRewards.subCap(appealCost);\n        }\n    }\n\n    /** @dev Reimburses contributions if no disputes were raised. If a dispute was raised, sends the fee stake rewards and reimbursements proportionally to the contributions made to the winner of a dispute.\n     *  @param _beneficiary The address that made contributions to a request.\n     *  @param _itemID The ID of the item submission to withdraw from.\n     *  @param _request The request from which to withdraw from.\n     *  @param _round The round from which to withdraw from.\n     */\n    function withdrawFeesAndRewards(address payable _beneficiary, bytes32 _itemID, uint _request, uint _round) public {\n        Item storage item = items[_itemID];\n        Request storage request = item.requests[_request];\n        Round storage round = request.rounds[_round];\n        require(request.resolved, \"Request must be resolved.\");\n\n        uint reward;\n        if (!round.hasPaid[uint(Party.Requester)] || !round.hasPaid[uint(Party.Challenger)]) {\n            // Reimburse if not enough fees were raised to appeal the ruling.\n            reward = round.contributions[_beneficiary][uint(Party.Requester)] + round.contributions[_beneficiary][uint(Party.Challenger)];\n        } else if (request.ruling == Party.None) {\n            // Reimburse unspent fees proportionally if there is no winner or loser.\n            uint rewardRequester = round.amountPaid[uint(Party.Requester)] > 0\n                ? (round.contributions[_beneficiary][uint(Party.Requester)] * round.feeRewards) / (round.amountPaid[uint(Party.Challenger)] + round.amountPaid[uint(Party.Requester)])\n                : 0;\n            uint rewardChallenger = round.amountPaid[uint(Party.Challenger)] > 0\n                ? (round.contributions[_beneficiary][uint(Party.Challenger)] * round.feeRewards) / (round.amountPaid[uint(Party.Challenger)] + round.amountPaid[uint(Party.Requester)])\n                : 0;\n\n            reward = rewardRequester + rewardChallenger;\n        } else {\n            // Reward the winner.\n            reward = round.amountPaid[uint(request.ruling)] > 0\n                ? (round.contributions[_beneficiary][uint(request.ruling)] * round.feeRewards) / round.amountPaid[uint(request.ruling)]\n                : 0;\n\n        }\n        round.contributions[_beneficiary][uint(Party.Requester)] = 0;\n        round.contributions[_beneficiary][uint(Party.Challenger)] = 0;\n\n        _beneficiary.send(reward);\n    }\n\n    /** @dev Executes an unchallenged request if the challenge period has passed.\n     *  @param _itemID The ID of the item to execute.\n     */\n    function executeRequest(bytes32 _itemID) external {\n        Item storage item = items[_itemID];\n        Request storage request = item.requests[item.requests.length - 1];\n        require(\n            now - request.submissionTime > challengePeriodDuration,\n            \"Time to challenge the request must pass.\"\n        );\n        require(!request.disputed, \"The request should not be disputed.\");\n\n        if (item.status == Status.RegistrationRequested)\n            item.status = Status.Registered;\n        else if (item.status == Status.ClearingRequested)\n            item.status = Status.Absent;\n        else\n            revert(\"There must be a request.\");\n\n        request.resolved = true;\n        emit ItemStatusChange(_itemID, item.requests.length - 1, request.rounds.length - 1, false, true);\n\n        withdrawFeesAndRewards(request.parties[uint(Party.Requester)], _itemID, item.requests.length - 1, 0); // Automatically withdraw for the requester.\n    }\n\n    /** @dev Give a ruling for a dispute. Can only be called by the arbitrator. TRUSTED.\n     *  Accounts for the situation where the winner loses a case due to paying less appeal fees than expected.\n     *  @param _disputeID ID of the dispute in the arbitrator contract.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Refused to arbitrate\".\n     */\n    function rule(uint _disputeID, uint _ruling) public {\n        Party resultRuling = Party(_ruling);\n        bytes32 itemID = arbitratorDisputeIDToItem[msg.sender][_disputeID];\n        Item storage item = items[itemID];\n\n        Request storage request = item.requests[item.requests.length - 1];\n        Round storage round = request.rounds[request.rounds.length - 1];\n        require(_ruling <= RULING_OPTIONS, \"Invalid ruling option\");\n        require(address(request.arbitrator) == msg.sender, \"Only the arbitrator can give a ruling\");\n        require(!request.resolved, \"The request must not be resolved.\");\n\n        // The ruling is inverted if the loser paid its fees.\n        if (round.hasPaid[uint(Party.Requester)] == true) // If one side paid its fees, the ruling is in its favor. Note that if the other side had also paid, an appeal would have been created.\n            resultRuling = Party.Requester;\n        else if (round.hasPaid[uint(Party.Challenger)] == true)\n            resultRuling = Party.Challenger;\n\n        emit Ruling(IArbitrator(msg.sender), _disputeID, uint(resultRuling));\n        executeRuling(_disputeID, uint(resultRuling));\n    }\n\n    /** @dev Submit a reference to evidence. EVENT.\n     *  @param _itemID The ID of the item which the evidence is related to.\n     *  @param _evidence A link to an evidence using its URI.\n     */\n    function submitEvidence(bytes32 _itemID, string calldata _evidence) external {\n        Item storage item = items[_itemID];\n        Request storage request = item.requests[item.requests.length - 1];\n        require(!request.resolved, \"The dispute must not already be resolved.\");\n\n        uint evidenceGroupID = uint(keccak256(abi.encodePacked(_itemID, item.requests.length - 1)));\n        emit Evidence(request.arbitrator, evidenceGroupID, msg.sender, _evidence);\n    }\n\n    // ************************ //\n    // *      Governance      * //\n    // ************************ //\n\n    /** @dev Change the duration of the challenge period.\n     *  @param _challengePeriodDuration The new duration of the challenge period.\n     */\n    function changeTimeToChallenge(uint _challengePeriodDuration) external onlyGovernor {\n        challengePeriodDuration = _challengePeriodDuration;\n    }\n\n    /** @dev Change the base amount required as a deposit to submit an item.\n     *  @param _submissionBaseDeposit The new base amount of wei required to submit an item.\n     */\n    function changeSubmissionBaseDeposit(uint _submissionBaseDeposit) external onlyGovernor {\n        submissionBaseDeposit = _submissionBaseDeposit;\n    }\n\n    /** @dev Change the base amount required as a deposit to remove an item.\n     *  @param _removalBaseDeposit The new base amount of wei required to remove an item.\n     */\n    function changeRemovalBaseDeposit(uint _removalBaseDeposit) external onlyGovernor {\n        removalBaseDeposit = _removalBaseDeposit;\n    }\n\n    /** @dev Change the base amount required as a deposit to challenge a submission.\n     *  @param _submissionChallengeBaseDeposit The new base amount of wei required to challenge a submission.\n     */\n    function changeSubmissionChallengeBaseDeposit(uint _submissionChallengeBaseDeposit) external onlyGovernor {\n        submissionChallengeBaseDeposit = _submissionChallengeBaseDeposit;\n    }\n\n    /** @dev Change the base amount required as a deposit to challenge a removal request.\n     *  @param _removalChallengeBaseDeposit The new base amount of wei required to challenge a removal request.\n     */\n    function changeRemovalChallengeBaseDeposit(uint _removalChallengeBaseDeposit) external onlyGovernor {\n        removalChallengeBaseDeposit = _removalChallengeBaseDeposit;\n    }\n\n    /** @dev Change the governor of the curated registry.\n     *  @param _governor The address of the new governor.\n     */\n    function changeGovernor(address _governor) external onlyGovernor {\n        governor = _governor;\n    }\n\n    /** @dev Change the proportion of arbitration fees that must be paid as fee stake by parties when there is no winner or loser.\n     *  @param _sharedStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeSharedStakeMultiplier(uint _sharedStakeMultiplier) external onlyGovernor {\n        sharedStakeMultiplier = _sharedStakeMultiplier;\n    }\n\n    /** @dev Change the proportion of arbitration fees that must be paid as fee stake by the winner of the previous round.\n     *  @param _winnerStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeWinnerStakeMultiplier(uint _winnerStakeMultiplier) external onlyGovernor {\n        winnerStakeMultiplier = _winnerStakeMultiplier;\n    }\n\n    /** @dev Change the proportion of arbitration fees that must be paid as fee stake by the party that lost the previous round.\n     *  @param _loserStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeLoserStakeMultiplier(uint _loserStakeMultiplier) external onlyGovernor {\n        loserStakeMultiplier = _loserStakeMultiplier;\n    }\n\n    /** @dev Change the arbitrator to be used for disputes that may be raised. The arbitrator is trusted to support appeal periods and not reenter.\n     *  @param _arbitrator The new trusted arbitrator to be used in disputes.\n     *  @param _arbitratorExtraData The extra data used by the new arbitrator.\n     */\n    function changeArbitrator(IArbitrator _arbitrator, bytes calldata _arbitratorExtraData) external onlyGovernor {\n        arbitrator = _arbitrator;\n        arbitratorExtraData = _arbitratorExtraData;\n    }\n\n    /** @dev Change the address of connectedTCR, the Generalized TCR instance that stores addresses of TCRs related to this one.\n     *  @param _connectedTCR The address of the connectedTCR contract to use.\n     */\n    function changeConnectedTCR(address _connectedTCR) external onlyGovernor {\n        emit ConnectedTCRSet(_connectedTCR);\n    }\n\n    /** @dev Update the meta evidence used for disputes.\n     *  @param _registrationMetaEvidence The meta evidence to be used for future registration request disputes.\n     *  @param _clearingMetaEvidence The meta evidence to be used for future clearing request disputes.\n     */\n    function changeMetaEvidence(string calldata _registrationMetaEvidence, string calldata _clearingMetaEvidence) external onlyGovernor {\n        metaEvidenceUpdates++;\n        emit MetaEvidence(2 * metaEvidenceUpdates, _registrationMetaEvidence);\n        emit MetaEvidence(2 * metaEvidenceUpdates + 1, _clearingMetaEvidence);\n    }\n\n    /* Internal */\n\n    /** @dev Submit a request to change item's status. Accepts enough ETH to cover the deposit, reimburses the rest.\n     *  @param _item The data describing the item.\n     *  @param _baseDeposit The base deposit for the request.\n     */\n    function requestStatusChange(bytes memory _item, uint _baseDeposit) internal {\n        bytes32 itemID = keccak256(_item);\n        Item storage item = items[itemID];\n\n        // Using `length` instead of `length - 1` as index because a new request will be added.\n        uint evidenceGroupID = uint(keccak256(abi.encodePacked(itemID, item.requests.length)));\n        if (item.requests.length == 0) {\n            item.data = _item;\n            itemList.push(itemID);\n            itemIDtoIndex[itemID] = itemList.length - 1;\n\n            emit ItemSubmitted(itemID, msg.sender, evidenceGroupID, item.data);\n        }\n\n        Request storage request = item.requests[item.requests.length++];\n        if (item.status == Status.Absent) {\n            item.status = Status.RegistrationRequested;\n            request.metaEvidenceID = 2 * metaEvidenceUpdates;\n        } else if (item.status == Status.Registered) {\n            item.status = Status.ClearingRequested;\n            request.metaEvidenceID = 2 * metaEvidenceUpdates + 1;\n        }\n\n        request.parties[uint(Party.Requester)] = msg.sender;\n        request.submissionTime = now;\n        request.arbitrator = arbitrator;\n        request.arbitratorExtraData = arbitratorExtraData;\n\n        Round storage round = request.rounds[request.rounds.length++];\n\n        uint arbitrationCost = request.arbitrator.arbitrationCost(request.arbitratorExtraData);\n        uint totalCost = arbitrationCost.addCap(_baseDeposit);\n        contribute(round, Party.Requester, msg.sender, msg.value, totalCost);\n        require(round.amountPaid[uint(Party.Requester)] >= totalCost, \"You must fully fund your side.\");\n        round.hasPaid[uint(Party.Requester)] = true;\n\n        emit ItemStatusChange(itemID, item.requests.length - 1, request.rounds.length - 1, false, false);\n        emit RequestSubmitted(itemID, item.requests.length - 1, item.status);\n        emit RequestEvidenceGroupID(itemID, item.requests.length - 1, evidenceGroupID);\n    }\n\n    /** @dev Returns the contribution value and remainder from available ETH and required amount.\n     *  @param _available The amount of ETH available for the contribution.\n     *  @param _requiredAmount The amount of ETH required for the contribution.\n     *  @return taken The amount of ETH taken.\n     *  @return remainder The amount of ETH left from the contribution.\n     */\n    function calculateContribution(uint _available, uint _requiredAmount)\n        internal\n        pure\n        returns(uint taken, uint remainder)\n    {\n        if (_requiredAmount > _available)\n            return (_available, 0); // Take whatever is available, return 0 as leftover ETH.\n        else\n            return (_requiredAmount, _available - _requiredAmount);\n    }\n\n    /** @dev Make a fee contribution.\n     *  @param _round The round to contribute.\n     *  @param _side The side for which to contribute.\n     *  @param _contributor The contributor.\n     *  @param _amount The amount contributed.\n     *  @param _totalRequired The total amount required for this side.\n     *  @return The amount of appeal fees contributed.\n     */\n    function contribute(Round storage _round, Party _side, address payable _contributor, uint _amount, uint _totalRequired) internal returns (uint) {\n        // Take up to the amount necessary to fund the current round at the current costs.\n        uint contribution; // Amount contributed.\n        uint remainingETH; // Remaining ETH to send back.\n        (contribution, remainingETH) = calculateContribution(_amount, _totalRequired.subCap(_round.amountPaid[uint(_side)]));\n        _round.contributions[_contributor][uint(_side)] += contribution;\n        _round.amountPaid[uint(_side)] += contribution;\n        _round.feeRewards += contribution;\n\n        // Reimburse leftover ETH.\n        _contributor.send(remainingETH); // Deliberate use of send in order to not block the contract in case of reverting fallback.\n\n        return contribution;\n    }\n\n    /** @dev Execute the ruling of a dispute.\n     *  @param _disputeID ID of the dispute in the arbitrator contract.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Refused to arbitrate\".\n     */\n    function executeRuling(uint _disputeID, uint _ruling) internal {\n        bytes32 itemID = arbitratorDisputeIDToItem[msg.sender][_disputeID];\n        Item storage item = items[itemID];\n        Request storage request = item.requests[item.requests.length - 1];\n\n        Party winner = Party(_ruling);\n\n        if (winner == Party.Requester) { // Execute Request.\n            if (item.status == Status.RegistrationRequested)\n                item.status = Status.Registered;\n            else if (item.status == Status.ClearingRequested)\n                item.status = Status.Absent;\n        } else {\n            if (item.status == Status.RegistrationRequested)\n                item.status = Status.Absent;\n            else if (item.status == Status.ClearingRequested)\n                item.status = Status.Registered;\n        }\n\n        request.resolved = true;\n        request.ruling = Party(_ruling);\n\n        emit ItemStatusChange(itemID, item.requests.length - 1, request.rounds.length - 1, true, true);\n\n        // Automatically withdraw first deposits and reimbursements (first round only).\n        if (winner == Party.None) {\n            withdrawFeesAndRewards(request.parties[uint(Party.Requester)], itemID, item.requests.length - 1, 0);\n            withdrawFeesAndRewards(request.parties[uint(Party.Challenger)], itemID, item.requests.length - 1, 0);\n        } else {\n            withdrawFeesAndRewards(request.parties[uint(winner)], itemID, item.requests.length - 1, 0);\n        }\n    }\n\n    // ************************ //\n    // *       Getters        * //\n    // ************************ //\n\n    /** @dev Returns the number of items that were submitted. Includes items that never made it to the list or were later removed.\n     *  @return count The number of items on the list.\n     */\n    function itemCount() external view returns (uint count) {\n        return itemList.length;\n    }\n\n    /** @dev Gets the contributions made by a party for a given round of a request.\n     *  @param _itemID The ID of the item.\n     *  @param _request The request to query.\n     *  @param _round The round to query.\n     *  @param _contributor The address of the contributor.\n     *  @return contributions The contributions.\n     */\n    function getContributions(\n        bytes32 _itemID,\n        uint _request,\n        uint _round,\n        address _contributor\n    ) external view returns(uint[3] memory contributions) {\n        Item storage item = items[_itemID];\n        Request storage request = item.requests[_request];\n        Round storage round = request.rounds[_round];\n        contributions = round.contributions[_contributor];\n    }\n\n    /** @dev Returns item's information. Includes length of requests array.\n     *  @param _itemID The ID of the queried item.\n     *  @return data The data describing the item.\n     *  @return status The current status of the item.\n     *  @return numberOfRequests Length of list of status change requests made for the item.\n     */\n    function getItemInfo(bytes32 _itemID)\n        external\n        view\n        returns (\n            bytes memory data,\n            Status status,\n            uint numberOfRequests\n        )\n    {\n        Item storage item = items[_itemID];\n        return (\n            item.data,\n            item.status,\n            item.requests.length\n        );\n    }\n\n    /** @dev Gets information on a request made for the item.\n     *  @param _itemID The ID of the queried item.\n     *  @param _request The request to be queried.\n     *  @return disputed True if a dispute was raised.\n     *  @return disputeID ID of the dispute, if any..\n     *  @return submissionTime Time when the request was made.\n     *  @return resolved True if the request was executed and/or any raised disputes were resolved.\n     *  @return parties Address of requester and challenger, if any.\n     *  @return numberOfRounds Number of rounds of dispute.\n     *  @return ruling The final ruling given, if any.\n     *  @return arbitrator The arbitrator trusted to solve disputes for this request.\n     *  @return arbitratorExtraData The extra data for the trusted arbitrator of this request.\n     *  @return metaEvidenceID The meta evidence to be used in a dispute for this case.\n     */\n    function getRequestInfo(bytes32 _itemID, uint _request)\n        external\n        view\n        returns (\n            bool disputed,\n            uint disputeID,\n            uint submissionTime,\n            bool resolved,\n            address payable[3] memory parties,\n            uint numberOfRounds,\n            Party ruling,\n            IArbitrator arbitrator,\n            bytes memory arbitratorExtraData,\n            uint metaEvidenceID\n        )\n    {\n        Request storage request = items[_itemID].requests[_request];\n        return (\n            request.disputed,\n            request.disputeID,\n            request.submissionTime,\n            request.resolved,\n            request.parties,\n            request.rounds.length,\n            request.ruling,\n            request.arbitrator,\n            request.arbitratorExtraData,\n            request.metaEvidenceID\n        );\n    }\n\n    /** @dev Gets the information of a round of a request.\n     *  @param _itemID The ID of the queried item.\n     *  @param _request The request to be queried.\n     *  @param _round The round to be queried.\n     *  @return appealed Whether appealed or not.\n     *  @return amountPaid Tracks the sum paid for each Party in this round.\n     *  @return hasPaid True if the Party has fully paid its fee in this round.\n     *  @return feeRewards Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\n     */\n    function getRoundInfo(bytes32 _itemID, uint _request, uint _round)\n        external\n        view\n        returns (\n            bool appealed,\n            uint[3] memory amountPaid,\n            bool[3] memory hasPaid,\n            uint feeRewards\n        )\n    {\n        Item storage item = items[_itemID];\n        Request storage request = item.requests[_request];\n        Round storage round = request.rounds[_round];\n        return (\n            _round != (request.rounds.length - 1),\n            round.amountPaid,\n            round.hasPaid,\n            round.feeRewards\n        );\n    }\n}\n"
    },
    "contracts/GTCRFactory.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: [@clesaege, @unknownunknown1, @ferittuncer, @satello, @MerlinEgalite]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\nimport { GeneralizedTCR, IArbitrator } from \"./GeneralizedTCR.sol\";\n\n/* solium-disable max-len */\n\n/**\n *  @title GTCRFactory\n *  This contract acts as a registry for GeneralizedTCR instances.\n */\ncontract GTCRFactory {\n\n    /**\n     *  @dev Emitted when a new Generalized TCR contract is deployed using this factory.\n     *  @param _address The address of the newly deployed Generalized TCR.\n     */\n    event NewGTCR(GeneralizedTCR indexed _address);\n\n    GeneralizedTCR[] public instances;\n\n    /**\n     *  @dev Deploy the arbitrable curated registry.\n     *  @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     *  @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     *  @param _connectedTCR The address of the TCR that stores related TCR addresses. This parameter can be left empty.\n     *  @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     *  @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     *  @param _governor The trusted governor of this contract.\n     *  @param _submissionBaseDeposit The base deposit to submit an item.\n     *  @param _removalBaseDeposit The base deposit to remove an item.\n     *  @param _submissionChallengeBaseDeposit The base deposit to challenge a submission.\n     *  @param _removalChallengeBaseDeposit The base deposit to challenge a removal request.\n     *  @param _challengePeriodDuration The time in seconds parties have to challenge a request.\n     *  @param _stakeMultipliers Multipliers of the arbitration cost in basis points (see GeneralizedTCR MULTIPLIER_DIVISOR) as follows:\n     *  - The multiplier applied to each party's fee stake for a round when there is no winner/loser in the previous round (e.g. when it's the first round or the arbitrator refused to arbitrate).\n     *  - The multiplier applied to the winner's fee stake for an appeal round.\n     *  - The multiplier applied to the loser's fee stake for an appeal round.\n     */\n    function deploy(\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        address _connectedTCR,\n        string memory _registrationMetaEvidence,\n        string memory _clearingMetaEvidence,\n        address _governor,\n        uint _submissionBaseDeposit,\n        uint _removalBaseDeposit,\n        uint _submissionChallengeBaseDeposit,\n        uint _removalChallengeBaseDeposit,\n        uint _challengePeriodDuration,\n        uint[3] memory _stakeMultipliers\n    ) public {\n        GeneralizedTCR instance = new GeneralizedTCR(\n                _arbitrator,\n                _arbitratorExtraData,\n                _connectedTCR,\n                _registrationMetaEvidence,\n                _clearingMetaEvidence,\n                _governor,\n                _submissionBaseDeposit,\n                _removalBaseDeposit,\n                _submissionChallengeBaseDeposit,\n                _removalChallengeBaseDeposit,\n                _challengePeriodDuration,\n                _stakeMultipliers\n        );\n        instances.push(instance);\n        emit NewGTCR(instance);\n    }\n\n    /**\n     * @return The number of deployed tcrs using this factory.\n     */\n    function count() external view returns (uint) {\n        return instances.length;\n    }\n}\n"
    },
    "contracts/LightBatchWithdraw.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\nimport {LightGeneralizedTCR} from \"./LightGeneralizedTCR.sol\";\n\n/**\n *  @title LightBatchWithdraw\n *  Withdraw fees and rewards from contributions to disputes rounds in batches.\n */\ncontract LightBatchWithdraw {\n    /** @dev Withdraws rewards and reimbursements of multiple rounds at once. This function is O(n) where n is the number of rounds. This could exceed gas limits, therefore this function should be used only as a utility and not be relied upon by other contracts.\n     *  @param _address The address of the LightGTCR.\n     *  @param _contributor The address that made contributions to the request.\n     *  @param _itemID The ID of the item with funds to be withdrawn.\n     *  @param _request The request from which to withdraw contributions.\n     *  @param _cursor The round from where to start withdrawing. Round 0 is always empty, so callers can safely start with 1.\n     *  @param _count The number of rounds to iterate. If set to 0 or a value larger than the number of rounds, iterates until the last round.\n     */\n    function batchRoundWithdraw(\n        address _address,\n        address payable _contributor,\n        bytes32 _itemID,\n        uint256 _request,\n        uint256 _cursor,\n        uint256 _count\n    ) public {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        (, , , , , uint256 numberOfRounds, , , , ) = gtcr.getRequestInfo(_itemID, _request);\n        for (uint256 i = _cursor; i < numberOfRounds && (_count == 0 || i < _cursor + _count); i++)\n            gtcr.withdrawFeesAndRewards(_contributor, _itemID, _request, i);\n    }\n\n    /** @dev Withdraws rewards and reimbursements of multiple requests at once. This function is O(n*m) where n is the number of requests and m is the number of rounds to withdraw per request. This could exceed gas limits, therefore this function should be used only as a utility and not be relied upon by other contracts.\n     *  @param _address The address of the GTCR.\n     *  @param _contributor The address that made contributions to the request.\n     *  @param _itemID The ID of the item with funds to be withdrawn.\n     *  @param _cursor The request from which to start withdrawing.\n     *  @param _count The number of requests to iterate. If set to 0 or a value larger than the number of request, iterates until the last request.\n     *  @param _roundCursor The round of each request from where to start withdrawing. Round 0 is always empty, so callers can safely start with 1.\n     *  @param _roundCount The number of rounds to iterate on each request. If set to 0 or a value larger than the number of rounds a request has, iteration for that request will stop at the last round.\n     */\n    function batchRequestWithdraw(\n        address _address,\n        address payable _contributor,\n        bytes32 _itemID,\n        uint256 _cursor,\n        uint256 _count,\n        uint256 _roundCursor,\n        uint256 _roundCount\n    ) external {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        (, uint256 numberOfRequests, ) = gtcr.getItemInfo(_itemID);\n        for (uint256 i = _cursor; i < numberOfRequests && (_count == 0 || i < _cursor + _count); i++)\n            batchRoundWithdraw(_address, _contributor, _itemID, i, _roundCursor, _roundCount);\n    }\n}\n"
    },
    "contracts/LightGeneralizedTCR.sol": {
      "content": "/**\n *  @authors: [@unknownunknown1*, @mtsalenc*, @hbarcelos*]\n *  @reviewers: [@fnanni-0*, @greenlucid, @shalzz]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity 0.5.17;\n\nimport {IArbitrable, IArbitrator} from \"@kleros/erc-792/contracts/IArbitrator.sol\";\nimport {IEvidence} from \"@kleros/erc-792/contracts/erc-1497/IEvidence.sol\";\nimport {CappedMath} from \"./utils/CappedMath.sol\";\nimport {CappedMath128} from \"./utils/CappedMath128.sol\";\n\n/* solium-disable max-len */\n/* solium-disable security/no-block-members */\n/* solium-disable security/no-send */\n// It is the user responsibility to accept ETH.\n\n/**\n *  @title LightGeneralizedTCR\n *  This contract is a curated registry for any types of items. Just like a TCR contract it features the request-challenge protocol and appeal fees crowdfunding.\n *  The difference between LightGeneralizedTCR and GeneralizedTCR is that instead of storing item data in storage and event logs, LightCurate only stores the URI of item in the logs. This makes it considerably cheaper to use and allows more flexibility with the item columns.\n */\ncontract LightGeneralizedTCR is IArbitrable, IEvidence {\n    using CappedMath for uint256;\n    using CappedMath128 for uint128;\n\n    /* Enums */\n\n    enum Status {\n        Absent, // The item is not in the registry.\n        Registered, // The item is in the registry.\n        RegistrationRequested, // The item has a request to be added to the registry.\n        ClearingRequested // The item has a request to be removed from the registry.\n    }\n\n    enum Party {\n        None, // Party per default when there is no challenger or requester. Also used for unconclusive ruling.\n        Requester, // Party that made the request to change a status.\n        Challenger // Party that challenges the request to change a status.\n    }\n\n    enum RequestType {\n        Registration, // Identifies a request to register an item to the registry.\n        Clearing // Identifies a request to remove an item from the registry.\n    }\n\n    enum DisputeStatus {\n        None, // No dispute was created.\n        AwaitingRuling, // Dispute was created, but the final ruling was not given yet.\n        Resolved // Dispute was ruled.\n    }\n\n    /* Structs */\n\n    struct Item {\n        Status status; // The current status of the item.\n        uint128 sumDeposit; // The total deposit made by the requester and the challenger (if any).\n        uint120 requestCount; // The number of requests.\n        mapping(uint256 => Request) requests; // List of status change requests made for the item in the form requests[requestID].\n    }\n\n    // Arrays with 3 elements map with the Party enum for better readability:\n    // - 0: is unused, matches `Party.None`.\n    // - 1: for `Party.Requester`.\n    // - 2: for `Party.Challenger`.\n    struct Request {\n        RequestType requestType;\n        uint64 submissionTime; // Time when the request was made. Used to track when the challenge period ends.\n        uint24 arbitrationParamsIndex; // The index for the arbitration params for the request.\n        address payable requester; // Address of the requester.\n        // Pack the requester together with the other parameters, as they are written in the same request.\n        address payable challenger; // Address of the challenger, if any.\n    }\n\n    struct DisputeData {\n        uint256 disputeID; // The ID of the dispute on the arbitrator.\n        DisputeStatus status; // The current status of the dispute.\n        Party ruling; // The ruling given to a dispute. Only set after it has been resolved.\n        uint240 roundCount; // The number of rounds.\n        mapping(uint256 => Round) rounds; // Data of the different dispute rounds. rounds[roundId].\n    }\n\n    struct Round {\n        Party sideFunded; // Stores the side that successfully paid the appeal fees in the latest round. Note that if both sides have paid a new round is created.\n        uint256 feeRewards; // Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\n        uint256[3] amountPaid; // Tracks the sum paid for each Party in this round.\n        mapping(address => uint256[3]) contributions; // Maps contributors to their contributions for each side in the form contributions[address][party].\n    }\n\n    struct ArbitrationParams {\n        IArbitrator arbitrator; // The arbitrator trusted to solve disputes for this request.\n        bytes arbitratorExtraData; // The extra data for the trusted arbitrator of this request.\n    }\n\n    /* Constants */\n\n    uint256 public constant RULING_OPTIONS = 2; // The amount of non 0 choices the arbitrator can give.\n    uint256 private constant RESERVED_ROUND_ID = 0; // For compatibility with GeneralizedTCR consider the request/challenge cycle the first round (index 0).\n\n    /* Storage */\n\n    bool private initialized;\n\n    address public relayerContract; // The contract that is used to add or remove items directly to speed up the interchain communication.\n    address public governor; // The address that can make changes to the parameters of the contract.\n\n    uint256 public submissionBaseDeposit; // The base deposit to submit an item.\n    uint256 public removalBaseDeposit; // The base deposit to remove an item.\n    uint256 public submissionChallengeBaseDeposit; // The base deposit to challenge a submission.\n    uint256 public removalChallengeBaseDeposit; // The base deposit to challenge a removal request.\n    uint256 public challengePeriodDuration; // The time after which a request becomes executable if not challenged.\n\n    // Multipliers are in basis points.\n    uint256 public winnerStakeMultiplier; // Multiplier for calculating the fee stake paid by the party that won the previous round.\n    uint256 public loserStakeMultiplier; // Multiplier for calculating the fee stake paid by the party that lost the previous round.\n    uint256 public sharedStakeMultiplier; // Multiplier for calculating the fee stake that must be paid in the case where arbitrator refused to arbitrate.\n    uint256 public constant MULTIPLIER_DIVISOR = 10000; // Divisor parameter for multipliers.\n\n    mapping(bytes32 => Item) public items; // Maps the item ID to its data in the form items[_itemID].\n    mapping(address => mapping(uint256 => bytes32)) public arbitratorDisputeIDToItemID; // Maps a dispute ID to the ID of the item with the disputed request in the form arbitratorDisputeIDToItemID[arbitrator][disputeID].\n    mapping(bytes32 => mapping(uint256 => DisputeData)) public requestsDisputeData; // Maps an item and a request to the data of the dispute related to them. requestsDisputeData[itemID][requestIndex]\n    ArbitrationParams[] public arbitrationParamsChanges;\n\n    /* Modifiers */\n\n    modifier onlyGovernor() {\n        require(msg.sender == governor, \"The caller must be the governor.\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(msg.sender == relayerContract, \"The caller must be the relay.\");\n        _;\n    }\n\n    /* Events */\n\n    /**\n     * @dev Emitted when a party makes a request, raises a dispute or when a request is resolved.\n     * @param _itemID The ID of the affected item.\n     * @param _updatedDirectly Whether this was emitted in either `addItemDirectly` or `removeItemDirectly`. This is used in the subgraph.\n     */\n    event ItemStatusChange(bytes32 indexed _itemID, bool _updatedDirectly);\n\n    /**\n     * @dev Emitted when someone submits an item for the first time.\n     * @param _itemID The ID of the new item.\n     * @param _data The item data URI.\n     * @param _addedDirectly Whether the item was added via `addItemDirectly`.\n     */\n    event NewItem(bytes32 indexed _itemID, string _data, bool _addedDirectly);\n\n    /**\n     * @dev Emitted when someone submits a request.\n     * @param _itemID The ID of the affected item.\n     * @param _evidenceGroupID Unique identifier of the evidence group the evidence belongs to.\n     */\n    event RequestSubmitted(bytes32 indexed _itemID, uint256 _evidenceGroupID);\n\n    /**\n     * @dev Emitted when a party contributes to an appeal. The roundID assumes the initial request and challenge deposits are the first round. This is done so indexers can know more information about the contribution without using call handlers.\n     * @param _itemID The ID of the item.\n     * @param _requestID The index of the request that received the contribution.\n     * @param _roundID The index of the round that received the contribution.\n     * @param _contributor The address making the contribution.\n     * @param _contribution How much of the contribution was accepted.\n     * @param _side The party receiving the contribution.\n     */\n    event Contribution(\n        bytes32 indexed _itemID,\n        uint256 _requestID,\n        uint256 _roundID,\n        address indexed _contributor,\n        uint256 _contribution,\n        Party _side\n    );\n\n    /**\n     * @dev Emitted when the address of the connected TCR is set. The connected TCR is an instance of the Generalized TCR contract where each item is the address of a TCR related to this one.\n     * @param _connectedTCR The address of the connected TCR.\n     */\n    event ConnectedTCRSet(address indexed _connectedTCR);\n\n    /**\n     * @dev Emitted when someone withdraws more than 0 rewards.\n     * @param _beneficiary The address that made contributions to a request.\n     * @param _itemID The ID of the item submission to withdraw from.\n     * @param _request The request from which to withdraw.\n     * @param _round The round from which to withdraw.\n     * @param _reward The amount withdrawn.\n     */\n    event RewardWithdrawn(\n        address indexed _beneficiary,\n        bytes32 indexed _itemID,\n        uint256 _request,\n        uint256 _round,\n        uint256 _reward\n    );\n\n    /**\n     * @dev Initialize the arbitrable curated registry.\n     * @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     * @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     * @param _connectedTCR The address of the TCR that stores related TCR addresses. This parameter can be left empty.\n     * @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     * @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     * @param _governor The trusted governor of this contract.\n     * @param _baseDeposits The base deposits for requests/challenges as follows:\n     * - The base deposit to submit an item.\n     * - The base deposit to remove an item.\n     * - The base deposit to challenge a submission.\n     * - The base deposit to challenge a removal request.\n     * @param _challengePeriodDuration The time in seconds parties have to challenge a request.\n     * @param _stakeMultipliers Multipliers of the arbitration cost in basis points (see MULTIPLIER_DIVISOR) as follows:\n     * - The multiplier applied to each party's fee stake for a round when there is no winner/loser in the previous round (e.g. when the arbitrator refused to arbitrate).\n     * - The multiplier applied to the winner's fee stake for the subsequent round.\n     * - The multiplier applied to the loser's fee stake for the subsequent round.\n     * @param _relayerContract The address of the relay contract to add/remove items directly.\n     */\n    function initialize(\n        IArbitrator _arbitrator,\n        bytes calldata _arbitratorExtraData,\n        address _connectedTCR,\n        string calldata _registrationMetaEvidence,\n        string calldata _clearingMetaEvidence,\n        address _governor,\n        uint256[4] calldata _baseDeposits,\n        uint256 _challengePeriodDuration,\n        uint256[3] calldata _stakeMultipliers,\n        address _relayerContract\n    ) external {\n        require(!initialized, \"Already initialized.\");\n\n        emit ConnectedTCRSet(_connectedTCR);\n\n        governor = _governor;\n        submissionBaseDeposit = _baseDeposits[0];\n        removalBaseDeposit = _baseDeposits[1];\n        submissionChallengeBaseDeposit = _baseDeposits[2];\n        removalChallengeBaseDeposit = _baseDeposits[3];\n        challengePeriodDuration = _challengePeriodDuration;\n        sharedStakeMultiplier = _stakeMultipliers[0];\n        winnerStakeMultiplier = _stakeMultipliers[1];\n        loserStakeMultiplier = _stakeMultipliers[2];\n        relayerContract = _relayerContract;\n\n        _doChangeArbitrationParams(_arbitrator, _arbitratorExtraData, _registrationMetaEvidence, _clearingMetaEvidence);\n\n        initialized = true;\n    }\n\n    /* External and Public */\n\n    // ************************ //\n    // *       Requests       * //\n    // ************************ //\n\n    /**\n     * @dev Directly add an item to the list bypassing request-challenge. Can only be used by the relay contract.\n     * @param _item The URI to the item data.\n     */\n    function addItemDirectly(string calldata _item) external onlyRelayer {\n        bytes32 itemID = keccak256(abi.encodePacked(_item));\n        Item storage item = items[itemID];\n        require(item.status == Status.Absent, \"Item must be absent to be added.\");\n\n        // Note that if the item is added directly once, the next time it is added it will emit this event again.\n        if (item.requestCount == 0) {\n            emit NewItem(itemID, _item, true);\n        }\n\n        item.status = Status.Registered;\n\n        emit ItemStatusChange(itemID, true);\n    }\n\n    /**\n     * @dev Directly remove an item from the list bypassing request-challenge. Can only be used by the relay contract.\n     * @param _itemID The ID of the item to remove.\n     */\n    function removeItemDirectly(bytes32 _itemID) external onlyRelayer {\n        Item storage item = items[_itemID];\n        require(item.status == Status.Registered, \"Item must be registered to be removed.\");\n\n        item.status = Status.Absent;\n\n        emit ItemStatusChange(_itemID, true);\n    }\n\n    /**\n     * @dev Submit a request to register an item. Accepts enough ETH to cover the deposit, reimburses the rest.\n     * @param _item The URI to the item data.\n     */\n    function addItem(string calldata _item) external payable {\n        bytes32 itemID = keccak256(abi.encodePacked(_item));\n        Item storage item = items[itemID];\n\n        // Extremely unlikely, but we check that for correctness sake.\n        require(item.requestCount < uint120(-1), \"Too many requests for item.\");\n        require(item.status == Status.Absent, \"Item must be absent to be added.\");\n\n        // Note that if the item was added previously using `addItemDirectly`, the event will be emitted again here.\n        if (item.requestCount == 0) {\n            emit NewItem(itemID, _item, false);\n        }\n\n        Request storage request = item.requests[item.requestCount++];\n        uint256 arbitrationParamsIndex = arbitrationParamsChanges.length - 1;\n        IArbitrator arbitrator = arbitrationParamsChanges[arbitrationParamsIndex].arbitrator;\n        bytes storage arbitratorExtraData = arbitrationParamsChanges[arbitrationParamsIndex].arbitratorExtraData;\n\n        uint256 arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\n        uint256 totalCost = arbitrationCost.addCap(submissionBaseDeposit);\n        require(msg.value >= totalCost, \"You must fully fund the request.\");\n\n        // Casting is safe here because this line will never be executed in case\n        // totalCost > type(uint128).max, since it would be an unpayable value.\n        item.sumDeposit = uint128(totalCost);\n        item.status = Status.RegistrationRequested;\n\n        request.requestType = RequestType.Registration;\n        request.submissionTime = uint64(block.timestamp);\n        request.arbitrationParamsIndex = uint24(arbitrationParamsIndex);\n        request.requester = msg.sender;\n\n        emit RequestSubmitted(itemID, getEvidenceGroupID(itemID, item.requestCount - 1));\n\n        emit Contribution(itemID, item.requestCount - 1, RESERVED_ROUND_ID, msg.sender, totalCost, Party.Requester);\n\n        if (msg.value > totalCost) {\n            msg.sender.send(msg.value - totalCost);\n        }\n    }\n\n    /**\n     * @dev Submit a request to remove an item from the list. Accepts enough ETH to cover the deposit, reimburses the rest.\n     * @param _itemID The ID of the item to remove.\n     * @param _evidence A link to an evidence using its URI. Ignored if not provided.\n     */\n    function removeItem(bytes32 _itemID, string calldata _evidence) external payable {\n        Item storage item = items[_itemID];\n\n        // Extremely unlikely, but we check that for correctness sake.\n        require(item.requestCount < uint120(-1), \"Too many requests for item.\");\n        require(item.status == Status.Registered, \"Item must be registered to be removed.\");\n\n        Request storage request = item.requests[item.requestCount++];\n        uint256 arbitrationParamsIndex = arbitrationParamsChanges.length - 1;\n        IArbitrator arbitrator = arbitrationParamsChanges[arbitrationParamsIndex].arbitrator;\n        bytes storage arbitratorExtraData = arbitrationParamsChanges[arbitrationParamsIndex].arbitratorExtraData;\n\n        uint256 arbitrationCost = arbitrator.arbitrationCost(arbitratorExtraData);\n        uint256 totalCost = arbitrationCost.addCap(removalBaseDeposit);\n        require(msg.value >= totalCost, \"You must fully fund the request.\");\n\n        // Casting is safe here because this line will never be executed in case\n        // totalCost > type(uint128).max, since it would be an unpayable value.\n        item.sumDeposit = uint128(totalCost);\n        item.status = Status.ClearingRequested;\n\n        request.submissionTime = uint64(block.timestamp);\n        request.arbitrationParamsIndex = uint24(arbitrationParamsIndex);\n        request.requester = msg.sender;\n        request.requestType = RequestType.Clearing;\n\n        uint256 evidenceGroupID = getEvidenceGroupID(_itemID, item.requestCount - 1);\n\n        emit RequestSubmitted(_itemID, evidenceGroupID);\n\n        emit Contribution(_itemID, item.requestCount - 1, RESERVED_ROUND_ID, msg.sender, totalCost, Party.Requester);\n\n        // Emit evidence if it was provided.\n        if (bytes(_evidence).length > 0) {\n            emit Evidence(arbitrator, evidenceGroupID, msg.sender, _evidence);\n        }\n\n        if (msg.value > totalCost) {\n            msg.sender.send(msg.value - totalCost);\n        }\n    }\n\n    /**\n     * @dev Challenges the request of the item. Accepts enough ETH to cover the deposit, reimburses the rest.\n     * @param _itemID The ID of the item which request to challenge.\n     * @param _evidence A link to an evidence using its URI. Ignored if not provided.\n     */\n    function challengeRequest(bytes32 _itemID, string calldata _evidence) external payable {\n        Item storage item = items[_itemID];\n        require(item.status > Status.Registered, \"The item must have a pending request.\");\n\n        uint256 lastRequestIndex = item.requestCount - 1;\n        Request storage request = item.requests[lastRequestIndex];\n        require(\n            block.timestamp - request.submissionTime <= challengePeriodDuration,\n            \"Challenges must occur during the challenge period.\"\n        );\n\n        DisputeData storage disputeData = requestsDisputeData[_itemID][lastRequestIndex];\n        require(disputeData.status == DisputeStatus.None, \"The request should not have already been disputed.\");\n\n        ArbitrationParams storage arbitrationParams = arbitrationParamsChanges[request.arbitrationParamsIndex];\n        IArbitrator arbitrator = arbitrationParams.arbitrator;\n\n        uint256 arbitrationCost = arbitrator.arbitrationCost(arbitrationParams.arbitratorExtraData);\n        uint256 totalCost;\n        {\n            uint256 challengerBaseDeposit = item.status == Status.RegistrationRequested\n                ? submissionChallengeBaseDeposit\n                : removalChallengeBaseDeposit;\n            totalCost = arbitrationCost.addCap(challengerBaseDeposit);\n        }\n        require(msg.value >= totalCost, \"You must fully fund the challenge.\");\n\n        emit Contribution(_itemID, lastRequestIndex, RESERVED_ROUND_ID, msg.sender, totalCost, Party.Challenger);\n\n        // Casting is safe here because this line will never be executed in case\n        // totalCost > type(uint128).max, since it would be an unpayable value.\n        item.sumDeposit = item.sumDeposit.addCap(uint128(totalCost)).subCap(uint128(arbitrationCost));\n\n        request.challenger = msg.sender;\n\n        // Raise a dispute.\n        disputeData.disputeID = arbitrator.createDispute.value(arbitrationCost)(\n            RULING_OPTIONS,\n            arbitrationParams.arbitratorExtraData\n        );\n        disputeData.status = DisputeStatus.AwaitingRuling;\n        // For compatibility with GeneralizedTCR consider the request/challenge cycle\n        // the first round (index 0), so we need to make the next round index 1.\n        disputeData.roundCount = 2;\n\n        arbitratorDisputeIDToItemID[address(arbitrator)][disputeData.disputeID] = _itemID;\n\n        uint256 metaEvidenceID = 2 * request.arbitrationParamsIndex + uint256(request.requestType);\n        uint256 evidenceGroupID = getEvidenceGroupID(_itemID, lastRequestIndex);\n        emit Dispute(arbitrator, disputeData.disputeID, metaEvidenceID, evidenceGroupID);\n\n        if (bytes(_evidence).length > 0) {\n            emit Evidence(arbitrator, evidenceGroupID, msg.sender, _evidence);\n        }\n\n        if (msg.value > totalCost) {\n            msg.sender.send(msg.value - totalCost);\n        }\n    }\n\n    /**\n     * @dev Takes up to the total amount required to fund a side of an appeal. Reimburses the rest. Creates an appeal if both sides are fully funded.\n     * @param _itemID The ID of the item which request to fund.\n     * @param _side The recipient of the contribution.\n     */\n    function fundAppeal(bytes32 _itemID, Party _side) external payable {\n        require(_side > Party.None, \"Invalid side.\");\n\n        Item storage item = items[_itemID];\n        require(item.status > Status.Registered, \"The item must have a pending request.\");\n\n        uint256 lastRequestIndex = item.requestCount - 1;\n        Request storage request = item.requests[lastRequestIndex];\n\n        DisputeData storage disputeData = requestsDisputeData[_itemID][lastRequestIndex];\n        require(\n            disputeData.status == DisputeStatus.AwaitingRuling,\n            \"A dispute must have been raised to fund an appeal.\"\n        );\n\n        ArbitrationParams storage arbitrationParams = arbitrationParamsChanges[request.arbitrationParamsIndex];\n        IArbitrator arbitrator = arbitrationParams.arbitrator;\n\n        uint256 lastRoundIndex = disputeData.roundCount - 1;\n        Round storage round = disputeData.rounds[lastRoundIndex];\n        require(round.sideFunded != _side, \"Side already fully funded.\");\n\n        uint256 multiplier;\n        {\n            (uint256 appealPeriodStart, uint256 appealPeriodEnd) = arbitrator.appealPeriod(disputeData.disputeID);\n            require(\n                block.timestamp >= appealPeriodStart && block.timestamp < appealPeriodEnd,\n                \"Contributions must be made within the appeal period.\"\n            );\n\n            Party winner = Party(arbitrator.currentRuling(disputeData.disputeID));\n            if (winner == Party.None) {\n                multiplier = sharedStakeMultiplier;\n            } else if (_side == winner) {\n                multiplier = winnerStakeMultiplier;\n            } else {\n                multiplier = loserStakeMultiplier;\n                require(\n                    block.timestamp < (appealPeriodStart + appealPeriodEnd) / 2,\n                    \"The loser must contribute during the first half of the appeal period.\"\n                );\n            }\n        }\n\n        uint256 appealCost = arbitrator.appealCost(disputeData.disputeID, arbitrationParams.arbitratorExtraData);\n        uint256 totalCost = appealCost.addCap(appealCost.mulCap(multiplier) / MULTIPLIER_DIVISOR);\n        contribute(_itemID, lastRequestIndex, lastRoundIndex, uint256(_side), msg.sender, msg.value, totalCost);\n\n        if (round.amountPaid[uint256(_side)] >= totalCost) {\n            if (round.sideFunded == Party.None) {\n                round.sideFunded = _side;\n            } else {\n                // Resets the value because both sides are funded.\n                round.sideFunded = Party.None;\n\n                // Raise appeal if both sides are fully funded.\n                arbitrator.appeal.value(appealCost)(disputeData.disputeID, arbitrationParams.arbitratorExtraData);\n                disputeData.roundCount++;\n                round.feeRewards = round.feeRewards.subCap(appealCost);\n            }\n        }\n    }\n\n    /**\n     * @dev If a dispute was raised, sends the fee stake rewards and reimbursements proportionally to the contributions made to the winner of a dispute.\n     * @param _beneficiary The address that made contributions to a request.\n     * @param _itemID The ID of the item submission to withdraw from.\n     * @param _requestID The request from which to withdraw from.\n     * @param _roundID The round from which to withdraw from.\n     */\n    function withdrawFeesAndRewards(\n        address payable _beneficiary,\n        bytes32 _itemID,\n        uint256 _requestID,\n        uint256 _roundID\n    ) external {\n        DisputeData storage disputeData = requestsDisputeData[_itemID][_requestID];\n\n        require(disputeData.status == DisputeStatus.Resolved, \"Request must be resolved.\");\n\n        Round storage round = disputeData.rounds[_roundID];\n\n        uint256 reward;\n        if (_roundID == disputeData.roundCount - 1) {\n            // Reimburse if not enough fees were raised to appeal the ruling.\n            reward =\n                round.contributions[_beneficiary][uint256(Party.Requester)] +\n                round.contributions[_beneficiary][uint256(Party.Challenger)];\n        } else if (disputeData.ruling == Party.None) {\n            uint256 totalFeesInRound = round.amountPaid[uint256(Party.Challenger)] +\n                round.amountPaid[uint256(Party.Requester)];\n            uint256 claimableFees = round.contributions[_beneficiary][uint256(Party.Challenger)] +\n                round.contributions[_beneficiary][uint256(Party.Requester)];\n            reward = totalFeesInRound > 0 ? (claimableFees * round.feeRewards) / totalFeesInRound : 0;\n        } else {\n            // Reward the winner.\n            reward = round.amountPaid[uint256(disputeData.ruling)] > 0\n                ? (round.contributions[_beneficiary][uint256(disputeData.ruling)] * round.feeRewards) /\n                    round.amountPaid[uint256(disputeData.ruling)]\n                : 0;\n        }\n        round.contributions[_beneficiary][uint256(Party.Requester)] = 0;\n        round.contributions[_beneficiary][uint256(Party.Challenger)] = 0;\n\n        if (reward > 0) {\n            _beneficiary.send(reward);\n            emit RewardWithdrawn(_beneficiary, _itemID, _requestID, _roundID, reward);\n        }\n    }\n\n    /**\n     * @dev Executes an unchallenged request if the challenge period has passed.\n     * @param _itemID The ID of the item to execute.\n     */\n    function executeRequest(bytes32 _itemID) external {\n        Item storage item = items[_itemID];\n        uint256 lastRequestIndex = items[_itemID].requestCount - 1;\n\n        Request storage request = item.requests[lastRequestIndex];\n        require(\n            block.timestamp - request.submissionTime > challengePeriodDuration,\n            \"Time to challenge the request must pass.\"\n        );\n\n        DisputeData storage disputeData = requestsDisputeData[_itemID][lastRequestIndex];\n        require(disputeData.status == DisputeStatus.None, \"The request should not be disputed.\");\n\n        if (item.status == Status.RegistrationRequested) {\n            item.status = Status.Registered;\n        } else if (item.status == Status.ClearingRequested) {\n            item.status = Status.Absent;\n        } else {\n            revert(\"There must be a request.\");\n        }\n\n        emit ItemStatusChange(_itemID, false);\n\n        uint256 sumDeposit = item.sumDeposit;\n        item.sumDeposit = 0;\n\n        if (sumDeposit > 0) {\n            // reimburse the requester\n            request.requester.send(sumDeposit);\n        }\n    }\n\n    /**\n     * @dev Give a ruling for a dispute. Can only be called by the arbitrator. TRUSTED.\n     * Accounts for the situation where the winner loses a case due to paying less appeal fees than expected.\n     * @param _disputeID ID of the dispute in the arbitrator contract.\n     * @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Refused to arbitrate\".\n     */\n    function rule(uint256 _disputeID, uint256 _ruling) external {\n        require(_ruling <= RULING_OPTIONS, \"Invalid ruling option\");\n\n        bytes32 itemID = arbitratorDisputeIDToItemID[msg.sender][_disputeID];\n        Item storage item = items[itemID];\n        uint256 lastRequestIndex = items[itemID].requestCount - 1;\n        Request storage request = item.requests[lastRequestIndex];\n\n        DisputeData storage disputeData = requestsDisputeData[itemID][lastRequestIndex];\n        require(disputeData.status == DisputeStatus.AwaitingRuling, \"The request must not be resolved.\");\n\n        ArbitrationParams storage arbitrationParams = arbitrationParamsChanges[request.arbitrationParamsIndex];\n        require(address(arbitrationParams.arbitrator) == msg.sender, \"Only the arbitrator can give a ruling\");\n\n        uint256 finalRuling;\n        Round storage round = disputeData.rounds[disputeData.roundCount - 1];\n\n        // If one side paid its fees, the ruling is in its favor.\n        // Note that if the other side had also paid, sideFudned would have been reset\n        // and an appeal would have been created.\n        if (round.sideFunded == Party.Requester) {\n            finalRuling = uint256(Party.Requester);\n        } else if (round.sideFunded == Party.Challenger) {\n            finalRuling = uint256(Party.Challenger);\n        } else {\n            finalRuling = _ruling;\n        }\n\n        emit Ruling(IArbitrator(msg.sender), _disputeID, finalRuling);\n\n        Party winner = Party(finalRuling);\n\n        disputeData.status = DisputeStatus.Resolved;\n        disputeData.ruling = winner;\n\n        uint256 sumDeposit = item.sumDeposit;\n        item.sumDeposit = 0;\n\n        if (winner == Party.None) {\n            // If the arbitrator refuse to rule, then the item status should be the same it was before the request.\n            // Regarding item.status this is equivalent to the challenger winning the dispute.\n            item.status = item.status == Status.RegistrationRequested ? Status.Absent : Status.Registered;\n\n            // Since nobody has won, then we reimburse both parties equally.\n            // If item.sumDeposit is odd, 1 wei will remain in the contract balance.\n            uint256 halfSumDeposit = sumDeposit / 2;\n\n            request.requester.send(halfSumDeposit);\n            request.challenger.send(halfSumDeposit);\n        } else if (winner == Party.Requester) {\n            item.status = item.status == Status.RegistrationRequested ? Status.Registered : Status.Absent;\n\n            request.requester.send(sumDeposit);\n        } else {\n            item.status = item.status == Status.RegistrationRequested ? Status.Absent : Status.Registered;\n\n            request.challenger.send(sumDeposit);\n        }\n\n        emit ItemStatusChange(itemID, false);\n    }\n\n    /**\n     * @dev Submit a reference to evidence. EVENT.\n     * @param _itemID The ID of the item which the evidence is related to.\n     * @param _evidence A link to an evidence using its URI.\n     */\n    function submitEvidence(bytes32 _itemID, string calldata _evidence) external {\n        Item storage item = items[_itemID];\n        uint256 lastRequestIndex = item.requestCount - 1;\n\n        Request storage request = item.requests[lastRequestIndex];\n        ArbitrationParams storage arbitrationParams = arbitrationParamsChanges[request.arbitrationParamsIndex];\n\n        emit Evidence(\n            arbitrationParams.arbitrator,\n            getEvidenceGroupID(_itemID, lastRequestIndex),\n            msg.sender,\n            _evidence\n        );\n    }\n\n    // ************************ //\n    // *      Governance      * //\n    // ************************ //\n\n    /**\n     * @dev Change the duration of the challenge period.\n     * @param _challengePeriodDuration The new duration of the challenge period.\n     */\n    function changeChallengePeriodDuration(uint256 _challengePeriodDuration) external onlyGovernor {\n        challengePeriodDuration = _challengePeriodDuration;\n    }\n\n    /**\n     * @dev Change the base amount required as a deposit to submit an item.\n     * @param _submissionBaseDeposit The new base amount of wei required to submit an item.\n     */\n    function changeSubmissionBaseDeposit(uint256 _submissionBaseDeposit) external onlyGovernor {\n        submissionBaseDeposit = _submissionBaseDeposit;\n    }\n\n    /**\n     * @dev Change the base amount required as a deposit to remove an item.\n     * @param _removalBaseDeposit The new base amount of wei required to remove an item.\n     */\n    function changeRemovalBaseDeposit(uint256 _removalBaseDeposit) external onlyGovernor {\n        removalBaseDeposit = _removalBaseDeposit;\n    }\n\n    /**\n     * @dev Change the base amount required as a deposit to challenge a submission.\n     * @param _submissionChallengeBaseDeposit The new base amount of wei required to challenge a submission.\n     */\n    function changeSubmissionChallengeBaseDeposit(uint256 _submissionChallengeBaseDeposit) external onlyGovernor {\n        submissionChallengeBaseDeposit = _submissionChallengeBaseDeposit;\n    }\n\n    /**\n     * @dev Change the base amount required as a deposit to challenge a removal request.\n     * @param _removalChallengeBaseDeposit The new base amount of wei required to challenge a removal request.\n     */\n    function changeRemovalChallengeBaseDeposit(uint256 _removalChallengeBaseDeposit) external onlyGovernor {\n        removalChallengeBaseDeposit = _removalChallengeBaseDeposit;\n    }\n\n    /**\n     * @dev Change the governor of the curated registry.\n     * @param _governor The address of the new governor.\n     */\n    function changeGovernor(address _governor) external onlyGovernor {\n        governor = _governor;\n    }\n\n    /**\n     * @dev Change the proportion of arbitration fees that must be paid as fee stake by parties when there is no winner or loser.\n     * @param _sharedStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeSharedStakeMultiplier(uint256 _sharedStakeMultiplier) external onlyGovernor {\n        sharedStakeMultiplier = _sharedStakeMultiplier;\n    }\n\n    /**\n     * @dev Change the proportion of arbitration fees that must be paid as fee stake by the winner of the previous round.\n     * @param _winnerStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeWinnerStakeMultiplier(uint256 _winnerStakeMultiplier) external onlyGovernor {\n        winnerStakeMultiplier = _winnerStakeMultiplier;\n    }\n\n    /**\n     * @dev Change the proportion of arbitration fees that must be paid as fee stake by the party that lost the previous round.\n     * @param _loserStakeMultiplier Multiplier of arbitration fees that must be paid as fee stake. In basis points.\n     */\n    function changeLoserStakeMultiplier(uint256 _loserStakeMultiplier) external onlyGovernor {\n        loserStakeMultiplier = _loserStakeMultiplier;\n    }\n\n    /**\n     * @dev Change the address of connectedTCR, the Generalized TCR instance that stores addresses of TCRs related to this one.\n     * @param _connectedTCR The address of the connectedTCR contract to use.\n     */\n    function changeConnectedTCR(address _connectedTCR) external onlyGovernor {\n        emit ConnectedTCRSet(_connectedTCR);\n    }\n\n    /**\n     * @dev Change the address of the relay contract.\n     * @param _relayerContract The new address of the relay contract.\n     */\n    function changeRelayerContract(address _relayerContract) external onlyGovernor {\n        relayerContract = _relayerContract;\n    }\n\n    /**\n     * @notice Changes the params related to arbitration.\n     * @dev Effectively makes all new items use the new set of params.\n     * @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     * @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     * @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     * @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     */\n    function changeArbitrationParams(\n        IArbitrator _arbitrator,\n        bytes calldata _arbitratorExtraData,\n        string calldata _registrationMetaEvidence,\n        string calldata _clearingMetaEvidence\n    ) external onlyGovernor {\n        _doChangeArbitrationParams(_arbitrator, _arbitratorExtraData, _registrationMetaEvidence, _clearingMetaEvidence);\n    }\n\n    /* Internal */\n\n    /**\n     * @dev Effectively makes all new items use the new set of params.\n     * @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     * @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     * @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     * @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     */\n    function _doChangeArbitrationParams(\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        string memory _registrationMetaEvidence,\n        string memory _clearingMetaEvidence\n    ) internal {\n        emit MetaEvidence(2 * arbitrationParamsChanges.length, _registrationMetaEvidence);\n        emit MetaEvidence(2 * arbitrationParamsChanges.length + 1, _clearingMetaEvidence);\n\n        arbitrationParamsChanges.push(\n            ArbitrationParams({arbitrator: _arbitrator, arbitratorExtraData: _arbitratorExtraData})\n        );\n    }\n\n    /**\n     * @notice Make a fee contribution.\n     * @dev It cannot be inlined in fundAppeal because of the stack limit.\n     * @param _itemID The item receiving the contribution.\n     * @param _requestID The request to contribute.\n     * @param _roundID The round to contribute.\n     * @param _side The side for which to contribute.\n     * @param _contributor The contributor.\n     * @param _amount The amount contributed.\n     * @param _totalRequired The total amount required for this side.\n     * @return The amount of appeal fees contributed.\n     */\n    function contribute(\n        bytes32 _itemID,\n        uint256 _requestID,\n        uint256 _roundID,\n        uint256 _side,\n        address payable _contributor,\n        uint256 _amount,\n        uint256 _totalRequired\n    ) internal {\n        Round storage round = requestsDisputeData[_itemID][_requestID].rounds[_roundID];\n        uint256 pendingAmount = _totalRequired.subCap(round.amountPaid[_side]);\n\n        // Take up to the amount necessary to fund the current round at the current costs.\n        uint256 contribution; // Amount contributed.\n        uint256 remainingETH; // Remaining ETH to send back.\n        if (pendingAmount > _amount) {\n            contribution = _amount;\n        } else {\n            contribution = pendingAmount;\n            remainingETH = _amount - pendingAmount;\n        }\n\n        round.contributions[_contributor][_side] += contribution;\n        round.amountPaid[_side] += contribution;\n        round.feeRewards += contribution;\n\n        // Reimburse leftover ETH.\n        if (remainingETH > 0) {\n            // Deliberate use of send in order to not block the contract in case of reverting fallback.\n            _contributor.send(remainingETH);\n        }\n\n        if (contribution > 0) {\n            emit Contribution(_itemID, _requestID, _roundID, msg.sender, contribution, Party(_side));\n        }\n    }\n\n    // ************************ //\n    // *       Getters        * //\n    // ************************ //\n\n    /**\n     * @dev Gets the evidengeGroupID for a given item and request.\n     * @param _itemID The ID of the item.\n     * @param _requestID The ID of the request.\n     * @return The evidenceGroupID\n     */\n    function getEvidenceGroupID(bytes32 _itemID, uint256 _requestID) public pure returns (uint256) {\n        return uint256(keccak256(abi.encodePacked(_itemID, _requestID)));\n    }\n\n    /**\n     * @notice Gets the arbitrator for new requests.\n     * @dev Gets the latest value in arbitrationParamsChanges.\n     * @return The arbitrator address.\n     */\n    function arbitrator() external view returns (IArbitrator) {\n        return arbitrationParamsChanges[arbitrationParamsChanges.length - 1].arbitrator;\n    }\n\n    /**\n     * @notice Gets the arbitratorExtraData for new requests.\n     * @dev Gets the latest value in arbitrationParamsChanges.\n     * @return The arbitrator extra data.\n     */\n    function arbitratorExtraData() external view returns (bytes memory) {\n        return arbitrationParamsChanges[arbitrationParamsChanges.length - 1].arbitratorExtraData;\n    }\n\n    /**\n     * @dev Gets the number of times MetaEvidence was updated.\n     * @return The number of times MetaEvidence was updated.\n     */\n    function metaEvidenceUpdates() external view returns (uint256) {\n        return arbitrationParamsChanges.length;\n    }\n\n    /**\n     * @dev Gets the contributions made by a party for a given round of a request.\n     * @param _itemID The ID of the item.\n     * @param _requestID The request to query.\n     * @param _roundID The round to query.\n     * @param _contributor The address of the contributor.\n     * @return contributions The contributions.\n     */\n    function getContributions(\n        bytes32 _itemID,\n        uint256 _requestID,\n        uint256 _roundID,\n        address _contributor\n    ) external view returns (uint256[3] memory contributions) {\n        DisputeData storage disputeData = requestsDisputeData[_itemID][_requestID];\n        Round storage round = disputeData.rounds[_roundID];\n        contributions = round.contributions[_contributor];\n    }\n\n    /**\n     * @dev Returns item's information. Includes the total number of requests for the item\n     * @param _itemID The ID of the queried item.\n     * @return status The current status of the item.\n     * @return numberOfRequests Total number of requests for the item.\n     * @return sumDeposit The total deposit made by the requester and the challenger (if any)\n     */\n    function getItemInfo(bytes32 _itemID)\n        external\n        view\n        returns (\n            Status status,\n            uint256 numberOfRequests,\n            uint256 sumDeposit\n        )\n    {\n        Item storage item = items[_itemID];\n        return (item.status, item.requestCount, item.sumDeposit);\n    }\n\n    /**\n     * @dev Gets information on a request made for the item.\n     * @param _itemID The ID of the queried item.\n     * @param _requestID The request to be queried.\n     * @return disputed True if a dispute was raised.\n     * @return disputeID ID of the dispute, if any.\n     * @return submissionTime Time when the request was made.\n     * @return resolved True if the request was executed and/or any raised disputes were resolved.\n     * @return parties Address of requester and challenger, if any.\n     * @return numberOfRounds Number of rounds of dispute.\n     * @return ruling The final ruling given, if any.\n     * @return arbitrator The arbitrator trusted to solve disputes for this request.\n     * @return arbitratorExtraData The extra data for the trusted arbitrator of this request.\n     * @return metaEvidenceID The meta evidence to be used in a dispute for this case.\n     */\n    function getRequestInfo(bytes32 _itemID, uint256 _requestID)\n        external\n        view\n        returns (\n            bool disputed,\n            uint256 disputeID,\n            uint256 submissionTime,\n            bool resolved,\n            address payable[3] memory parties,\n            uint256 numberOfRounds,\n            Party ruling,\n            IArbitrator requestArbitrator,\n            bytes memory requestArbitratorExtraData,\n            uint256 metaEvidenceID\n        )\n    {\n        Item storage item = items[_itemID];\n        require(item.requestCount > _requestID, \"Request does not exist.\");\n\n        Request storage request = items[_itemID].requests[_requestID];\n\n        submissionTime = request.submissionTime;\n        parties[uint256(Party.Requester)] = request.requester;\n        parties[uint256(Party.Challenger)] = request.challenger;\n\n        (disputed, disputeID, numberOfRounds, ruling) = getRequestDisputeData(_itemID, _requestID);\n\n        (requestArbitrator, requestArbitratorExtraData, metaEvidenceID) = getRequestArbitrationParams(\n            _itemID,\n            _requestID\n        );\n        resolved = getRequestResolvedStatus(_itemID, _requestID);\n    }\n\n    /**\n     * @dev Gets the dispute data relative to a given item request.\n     * @param _itemID The ID of the queried item.\n     * @param _requestID The request to be queried.\n     * @return disputed True if a dispute was raised.\n     * @return disputeID ID of the dispute, if any.\n     * @return ruling The final ruling given, if any.\n     * @return numberOfRounds Number of rounds of dispute.\n     */\n    function getRequestDisputeData(bytes32 _itemID, uint256 _requestID)\n        internal\n        view\n        returns (\n            bool disputed,\n            uint256 disputeID,\n            uint256 numberOfRounds,\n            Party ruling\n        )\n    {\n        DisputeData storage disputeData = requestsDisputeData[_itemID][_requestID];\n\n        return (\n            disputeData.status >= DisputeStatus.AwaitingRuling,\n            disputeData.disputeID,\n            disputeData.roundCount,\n            disputeData.ruling\n        );\n    }\n\n    /**\n     * @dev Gets the arbitration params relative to a given item request.\n     * @param _itemID The ID of the queried item.\n     * @param _requestID The request to be queried.\n     * @return arbitrator The arbitrator trusted to solve disputes for this request.\n     * @return arbitratorExtraData The extra data for the trusted arbitrator of this request.\n     * @return metaEvidenceID The meta evidence to be used in a dispute for this case.\n     */\n    function getRequestArbitrationParams(bytes32 _itemID, uint256 _requestID)\n        internal\n        view\n        returns (\n            IArbitrator arbitrator,\n            bytes memory arbitratorExtraData,\n            uint256 metaEvidenceID\n        )\n    {\n        Request storage request = items[_itemID].requests[_requestID];\n        ArbitrationParams storage arbitrationParams = arbitrationParamsChanges[request.arbitrationParamsIndex];\n\n        return (\n            arbitrationParams.arbitrator,\n            arbitrationParams.arbitratorExtraData,\n            2 * request.arbitrationParamsIndex + uint256(request.requestType)\n        );\n    }\n\n    /**\n     * @dev Gets the resovled status of a given item request.\n     * @param _itemID The ID of the queried item.\n     * @param _requestID The request to be queried.\n     * @return resolved True if the request was executed and/or any raised disputes were resolved.\n     */\n    function getRequestResolvedStatus(bytes32 _itemID, uint256 _requestID) internal view returns (bool resolved) {\n        Item storage item = items[_itemID];\n\n        if (item.requestCount == 0) {\n            return false;\n        }\n\n        if (_requestID < item.requestCount - 1) {\n            // It was resolved because it is not the last request.\n            return true;\n        }\n\n        return item.sumDeposit == 0;\n    }\n\n    /**\n     * @dev Gets the information of a round of a request.\n     * @param _itemID The ID of the queried item.\n     * @param _requestID The request to be queried.\n     * @param _roundID The round to be queried.\n     * @return appealed Whether appealed or not.\n     * @return amountPaid Tracks the sum paid for each Party in this round.\n     * @return hasPaid True if the Party has fully paid its fee in this round.\n     * @return feeRewards Sum of reimbursable fees and stake rewards available to the parties that made contributions to the side that ultimately wins a dispute.\n     */\n    function getRoundInfo(\n        bytes32 _itemID,\n        uint256 _requestID,\n        uint256 _roundID\n    )\n        external\n        view\n        returns (\n            bool appealed,\n            uint256[3] memory amountPaid,\n            bool[3] memory hasPaid,\n            uint256 feeRewards\n        )\n    {\n        Item storage item = items[_itemID];\n        require(item.requestCount > _requestID, \"Request does not exist.\");\n\n        DisputeData storage disputeData = requestsDisputeData[_itemID][_requestID];\n        require(disputeData.roundCount > _roundID, \"Round does not exist\");\n\n        Round storage round = disputeData.rounds[_roundID];\n        appealed = _roundID < disputeData.roundCount - 1;\n\n        hasPaid[uint256(Party.Requester)] = appealed || round.sideFunded == Party.Requester;\n        hasPaid[uint256(Party.Challenger)] = appealed || round.sideFunded == Party.Challenger;\n\n        return (appealed, round.amountPaid, hasPaid, round.feeRewards);\n    }\n}\n"
    },
    "contracts/LightGTCRFactory.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: [@fnanni-0, @shalzz]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\nimport {LightGeneralizedTCR, IArbitrator} from \"./LightGeneralizedTCR.sol\";\n\n/* solium-disable max-len */\n\n/**\n *  @title LightGTCRFactory\n *  This contract acts as a registry for LightGeneralizedTCR instances.\n */\ncontract LightGTCRFactory {\n    /**\n     *  @dev Emitted when a new Generalized TCR contract is deployed using this factory.\n     *  @param _address The address of the newly deployed Generalized TCR.\n     */\n    event NewGTCR(LightGeneralizedTCR indexed _address);\n\n    LightGeneralizedTCR[] public instances;\n    address public GTCR;\n\n    /**\n     *  @dev Constructor.\n     *  @param _GTCR Address of the generalized TCR contract that is going to be used for each new deployment.\n     */\n    constructor(address _GTCR) public {\n        GTCR = _GTCR;\n    }\n\n    /**\n     *  @dev Deploy the arbitrable curated registry.\n     *  @param _arbitrator Arbitrator to resolve potential disputes. The arbitrator is trusted to support appeal periods and not reenter.\n     *  @param _arbitratorExtraData Extra data for the trusted arbitrator contract.\n     *  @param _connectedTCR The address of the TCR that stores related TCR addresses. This parameter can be left empty.\n     *  @param _registrationMetaEvidence The URI of the meta evidence object for registration requests.\n     *  @param _clearingMetaEvidence The URI of the meta evidence object for clearing requests.\n     *  @param _governor The trusted governor of this contract.\n     *  @param _baseDeposits The base deposits for requests/challenges as follows:\n     *  - The base deposit to submit an item.\n     *  - The base deposit to remove an item.\n     *  - The base deposit to challenge a submission.\n     *  - The base deposit to challenge a removal request.\n     *  @param _challengePeriodDuration The time in seconds parties have to challenge a request.\n     *  @param _stakeMultipliers Multipliers of the arbitration cost in basis points (see LightGeneralizedTCR MULTIPLIER_DIVISOR) as follows:\n     *  - The multiplier applied to each party's fee stake for a round when there is no winner/loser in the previous round.\n     *  - The multiplier applied to the winner's fee stake for an appeal round.\n     *  - The multiplier applied to the loser's fee stake for an appeal round.\n     *  @param _relayContract The address of the relay contract to add/remove items directly.\n     */\n    function deploy(\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        address _connectedTCR,\n        string memory _registrationMetaEvidence,\n        string memory _clearingMetaEvidence,\n        address _governor,\n        uint256[4] memory _baseDeposits,\n        uint256 _challengePeriodDuration,\n        uint256[3] memory _stakeMultipliers,\n        address _relayContract\n    ) public {\n        LightGeneralizedTCR instance = clone(GTCR);\n        instance.initialize(\n            _arbitrator,\n            _arbitratorExtraData,\n            _connectedTCR,\n            _registrationMetaEvidence,\n            _clearingMetaEvidence,\n            _governor,\n            _baseDeposits,\n            _challengePeriodDuration,\n            _stakeMultipliers,\n            _relayContract\n        );\n        instances.push(instance);\n        emit NewGTCR(instance);\n    }\n\n    /**\n     * @notice Adaptation of @openzeppelin/contracts/proxy/Clones.sol.\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `GTCR`.\n     * @param _implementation Address of the contract to clone.\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address _implementation) internal returns (LightGeneralizedTCR instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, _implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != LightGeneralizedTCR(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @return The number of deployed tcrs using this factory.\n     */\n    function count() external view returns (uint256) {\n        return instances.length;\n    }\n}\n"
    },
    "contracts/test-purposes/AppealableArbitrator.sol": {
      "content": "/**\n*  https://contributing.kleros.io/smart-contract-workflow\n*  @authors: [@epiqueras, @ferittuncer, @unknownunknown1, @mtsalenc]\n*  @reviewers: []\n*  @auditors: []\n*  @bounties: []\n*  @deployments: []\n*/\n\npragma solidity ^0.5.11;\n\nimport \"./CentralizedArbitrator.sol\";\n\n/**\n *  @title AppealableArbitrator\n *  @dev A centralized arbitrator that can be appealed.\n */\ncontract AppealableArbitrator is CentralizedArbitrator, IArbitrable {\n    /* Structs */\n\n    struct AppealDispute {\n        uint rulingTime;\n        IArbitrator arbitrator;\n        uint appealDisputeID;\n    }\n\n    /* Modifiers */\n\n    modifier onlyArbitrator {require(msg.sender == address(arbitrator), \"Can only be called by the arbitrator.\"); _;}\n    modifier requireAppealFee(uint _disputeID, bytes memory _extraData) {\n        require(msg.value >= appealCost(_disputeID, _extraData), \"Not enough ETH to cover appeal costs.\");\n        _;\n    }\n\n    /* Storage */\n\n    uint public timeOut;\n    mapping(uint => AppealDispute) public appealDisputes;\n    mapping(uint => uint) public appealDisputeIDsToDisputeIDs;\n    IArbitrator public arbitrator;\n    bytes public arbitratorExtraData; // Extra data to require particular dispute and appeal behaviour.\n\n    /* Constructor */\n\n    /** @dev Constructs the `AppealableArbitrator` contract.\n     *  @param _arbitrationPrice The amount to be paid for arbitration.\n     *  @param _arbitrator The back up arbitrator.\n     *  @param _arbitratorExtraData Not used by this contract.\n     *  @param _timeOut The time out for the appeal period.\n     */\n    constructor(\n        uint _arbitrationPrice,\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        uint _timeOut\n    ) public CentralizedArbitrator(_arbitrationPrice) {\n        timeOut = _timeOut;\n    }\n\n    /* External */\n\n    /** @dev Changes the back up arbitrator.\n     *  @param _arbitrator The new back up arbitrator.\n     */\n    function changeArbitrator(IArbitrator _arbitrator) external onlyOwner {\n        arbitrator = _arbitrator;\n    }\n\n    /** @dev Changes the time out.\n     *  @param _timeOut The new time out.\n     */\n    function changeTimeOut(uint _timeOut) external onlyOwner {\n        timeOut = _timeOut;\n    }\n\n    /* External Views */\n\n    /** @dev Gets the specified dispute's latest appeal ID.\n     *  @param _disputeID The ID of the dispute.\n     */\n    function getAppealDisputeID(uint _disputeID) external view returns(uint disputeID) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0)))\n            disputeID = AppealableArbitrator(address(appealDisputes[_disputeID].arbitrator)).getAppealDisputeID(appealDisputes[_disputeID].appealDisputeID);\n        else disputeID = _disputeID;\n    }\n\n    /* Public */\n\n    /** @dev Appeals a ruling.\n     *  @param _disputeID The ID of the dispute.\n     *  @param _extraData Additional info about the appeal.\n     */\n    function appeal(uint _disputeID, bytes memory _extraData) public payable requireAppealFee(_disputeID, _extraData) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0)))\n            appealDisputes[_disputeID].arbitrator.appeal.value(msg.value)(appealDisputes[_disputeID].appealDisputeID, _extraData);\n        else {\n            appealDisputes[_disputeID].arbitrator = arbitrator;\n            appealDisputes[_disputeID].appealDisputeID = arbitrator.createDispute.value(msg.value)(disputes[_disputeID].choices, _extraData);\n            appealDisputeIDsToDisputeIDs[appealDisputes[_disputeID].appealDisputeID] = _disputeID;\n        }\n    }\n\n    /** @dev Gives a ruling.\n     *  @param _disputeID The ID of the dispute.\n     *  @param _ruling The ruling.\n     */\n    function giveRuling(uint _disputeID, uint _ruling) public {\n        require(disputes[_disputeID].status != DisputeStatus.Solved, \"The specified dispute is already resolved.\");\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0))) {\n            require(IArbitrator(msg.sender) == appealDisputes[_disputeID].arbitrator, \"Appealed disputes must be ruled by their back up arbitrator.\");\n            super._giveRuling(_disputeID, _ruling);\n        } else {\n            require(msg.sender == owner, \"Not appealed disputes must be ruled by the owner.\");\n            if (disputes[_disputeID].status == DisputeStatus.Appealable) {\n                if (now - appealDisputes[_disputeID].rulingTime > timeOut)\n                    super._giveRuling(_disputeID, disputes[_disputeID].ruling);\n                else revert(\"Time out time has not passed yet.\");\n            } else {\n                disputes[_disputeID].ruling = _ruling;\n                disputes[_disputeID].status = DisputeStatus.Appealable;\n                appealDisputes[_disputeID].rulingTime = now;\n                emit AppealPossible(_disputeID, disputes[_disputeID].arbitrated);\n            }\n        }\n    }\n\n    /** @dev Give a ruling for a dispute. Must be called by the arbitrator.\n     *  The purpose of this function is to ensure that the address calling it has the right to rule on the contract.\n     *  @param _disputeID ID of the dispute in the IArbitrator contract.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 is reserved for \"Not able/wanting to make a decision\".\n     */\n    function rule(uint _disputeID, uint _ruling) public onlyArbitrator {\n        emit Ruling(IArbitrator(msg.sender),_disputeID,_ruling);\n\n        executeRuling(_disputeID,_ruling);\n    }\n\n    /* Public Views */\n\n    /** @dev Gets the cost of appeal for the specified dispute.\n     *  @param _disputeID The ID of the dispute.\n     *  @param _extraData Additional info about the appeal.\n     *  @return The cost of the appeal.\n     */\n    function appealCost(uint _disputeID, bytes memory _extraData) public view returns(uint cost) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0)))\n            cost = appealDisputes[_disputeID].arbitrator.appealCost(appealDisputes[_disputeID].appealDisputeID, _extraData);\n        else if (disputes[_disputeID].status == DisputeStatus.Appealable) cost = arbitrator.arbitrationCost(_extraData);\n        else cost = NOT_PAYABLE_VALUE;\n    }\n\n    /** @dev Gets the status of the specified dispute.\n     *  @param _disputeID The ID of the dispute.\n     *  @return The status.\n     */\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0)))\n            status = appealDisputes[_disputeID].arbitrator.disputeStatus(appealDisputes[_disputeID].appealDisputeID);\n        else status = disputes[_disputeID].status;\n    }\n\n    /** @dev Return the ruling of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return ruling The ruling which would or has been given.\n     */\n    function currentRuling(uint _disputeID) public view returns(uint ruling) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0))) // Appealed.\n            ruling = appealDisputes[_disputeID].arbitrator.currentRuling(appealDisputes[_disputeID].appealDisputeID); // Retrieve ruling from the arbitrator whom the dispute is appealed to.\n        else ruling = disputes[_disputeID].ruling; //  Not appealed, basic case.\n    }\n\n    /* Internal */\n\n    /** @dev Executes the ruling of the specified dispute.\n     *  @param _disputeID The ID of the dispute.\n     *  @param _ruling The ruling.\n     */\n    function executeRuling(uint _disputeID, uint _ruling) internal {\n        require(\n            appealDisputes[appealDisputeIDsToDisputeIDs[_disputeID]].arbitrator != IArbitrator(address(0)),\n            \"The dispute must have been appealed.\"\n        );\n        giveRuling(appealDisputeIDsToDisputeIDs[_disputeID], _ruling);\n    }\n}"
    },
    "contracts/test-purposes/CentralizedArbitrator.sol": {
      "content": "/**\n *  @authors: [@clesaege, @n1c01a5, @epiqueras, @ferittuncer, @unknownunknown1, @mtsalenc]\n *  @reviewers: [@clesaege*, @unknownunknown1*]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.11;\n\nimport { IArbitrator, IArbitrable } from \"@kleros/erc-792/contracts/IArbitrator.sol\";\n\n/** @title Centralized Arbitrator\n *  @dev This is a centralized arbitrator deciding alone on the result of disputes. No appeals are possible.\n */\ncontract CentralizedArbitrator is IArbitrator {\n\n    address public owner = msg.sender;\n    uint arbitrationPrice; // Not public because arbitrationCost already acts as an accessor.\n    uint constant NOT_PAYABLE_VALUE = (2**256-2)/2; // High value to be sure that the appeal is too expensive.\n\n    struct DisputeStruct {\n        IArbitrable arbitrated;\n        uint choices;\n        uint fee;\n        uint ruling;\n        DisputeStatus status;\n    }\n\n    modifier onlyOwner {require(msg.sender==owner, \"Can only be called by the owner.\"); _;}\n    modifier requireArbitrationFee(bytes memory _extraData) {\n        require(msg.value >= arbitrationCost(_extraData), \"Not enough ETH to cover arbitration costs.\");\n        _;\n    }\n\n    DisputeStruct[] public disputes;\n\n    /** @dev Constructor. Set the initial arbitration price.\n     *  @param _arbitrationPrice Amount to be paid for arbitration.\n     */\n    constructor(uint _arbitrationPrice) public {\n        arbitrationPrice = _arbitrationPrice;\n    }\n\n    /** @dev Set the arbitration price. Only callable by the owner.\n     *  @param _arbitrationPrice Amount to be paid for arbitration.\n     */\n    function setArbitrationPrice(uint _arbitrationPrice) public onlyOwner {\n        arbitrationPrice = _arbitrationPrice;\n    }\n\n    /** @dev Cost of arbitration. Accessor to arbitrationPrice.\n     *  @param _extraData Not used by this contract.\n     *  @return fee Amount to be paid.\n     */\n    function arbitrationCost(bytes memory _extraData) public view returns(uint fee) {\n        return arbitrationPrice;\n    }\n\n    /** @dev Cost of appeal. Since it is not possible, it's a high value which can never be paid.\n     *  @param _disputeID ID of the dispute to be appealed. Not used by this contract.\n     *  @param _extraData Not used by this contract.\n     *  @return fee Amount to be paid.\n     */\n    function appealCost(uint _disputeID, bytes memory _extraData) public view returns(uint fee) {\n        return NOT_PAYABLE_VALUE;\n    }\n\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\n     *  Must be paid at least arbitrationCost().\n     *  @param _choices Amount of choices the arbitrator can make in this dispute. When ruling ruling<=choices.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint _choices, bytes memory _extraData) public payable requireArbitrationFee(_extraData) returns(uint disputeID)  {\n        disputeID = disputes.push(DisputeStruct({\n            arbitrated: IArbitrable(msg.sender),\n            choices: _choices,\n            fee: msg.value,\n            ruling: 0,\n            status: DisputeStatus.Waiting\n            })) - 1; // Create the dispute and return its number.\n        emit DisputeCreation(disputeID, IArbitrable(msg.sender));\n    }\n\n    /** @dev Give a ruling. UNTRUSTED.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 means \"Not able/wanting to make a decision\".\n     */\n    function _giveRuling(uint _disputeID, uint _ruling) internal {\n        DisputeStruct storage dispute = disputes[_disputeID];\n        require(_ruling <= dispute.choices, \"Invalid ruling.\");\n        require(dispute.status != DisputeStatus.Solved, \"The dispute must not be solved already.\");\n\n        dispute.ruling = _ruling;\n        dispute.status = DisputeStatus.Solved;\n\n        msg.sender.send(dispute.fee); // Avoid blocking.\n        dispute.arbitrated.rule(_disputeID,_ruling);\n    }\n\n    /** @dev Give a ruling. UNTRUSTED.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @param _ruling Ruling given by the arbitrator. Note that 0 means \"Not able/wanting to make a decision\".\n     */\n    function giveRuling(uint _disputeID, uint _ruling) public onlyOwner {\n        return _giveRuling(_disputeID, _ruling);\n    }\n\n    /** @dev Return the status of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return status The status of the dispute.\n     */\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status) {\n        return disputes[_disputeID].status;\n    }\n\n    /** @dev Return the ruling of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return ruling The ruling which would or has been given.\n     */\n    function currentRuling(uint _disputeID) public view returns(uint ruling) {\n        return disputes[_disputeID].ruling;\n    }\n}"
    },
    "contracts/test-purposes/EnhancedAppealableArbitrator.sol": {
      "content": "/**\n *  @authors: [@epiqueras, @unknownunknown1, @mtsalenc]\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.11;\n\nimport \"./AppealableArbitrator.sol\";\n\n/**\n *  @title EnhancedAppealableArbitrator\n *  @author Enrique Piqueras - <epiquerass@gmail.com>\n *  @dev Implementation of `AppealableArbitrator` that supports `appealPeriod`.\n */\ncontract EnhancedAppealableArbitrator is AppealableArbitrator {\n    /* Constructor */\n\n    /* solium-disable no-empty-blocks */\n    /** @dev Constructs the `EnhancedAppealableArbitrator` contract.\n     *  @param _arbitrationPrice The amount to be paid for arbitration.\n     *  @param _arbitrator The back up arbitrator.\n     *  @param _arbitratorExtraData Not used by this contract.\n     *  @param _timeOut The time out for the appeal period.\n     */\n    constructor(\n        uint256 _arbitrationPrice,\n        IArbitrator _arbitrator,\n        bytes memory _arbitratorExtraData,\n        uint256 _timeOut\n    ) public AppealableArbitrator(_arbitrationPrice, _arbitrator, _arbitratorExtraData, _timeOut) {}\n\n    /* solium-enable no-empty-blocks */\n\n    /* Public Views */\n\n    /** @dev Compute the start and end of the dispute's current or next appeal period, if possible.\n     *  @param _disputeID ID of the dispute.\n     *  @return The start and end of the period.\n     */\n    function appealPeriod(uint256 _disputeID) public view returns (uint256 start, uint256 end) {\n        if (appealDisputes[_disputeID].arbitrator != IArbitrator(address(0)))\n            (start, end) = appealDisputes[_disputeID].arbitrator.appealPeriod(\n                appealDisputes[_disputeID].appealDisputeID\n            );\n        else {\n            start = appealDisputes[_disputeID].rulingTime;\n            require(start != 0, \"The specified dispute is not appealable.\");\n            end = start + timeOut;\n        }\n    }\n\n    /** @dev Appeals a ruling.\n     *  @param _disputeID The ID of the dispute.\n     *  @param _extraData Additional info about the appeal.\n     */\n    function appeal(uint256 _disputeID, bytes memory _extraData)\n        public\n        payable\n        requireAppealFee(_disputeID, _extraData)\n    {\n        emit AppealDecision(_disputeID, IArbitrable(msg.sender));\n        return super.appeal(_disputeID, _extraData);\n    }\n}\n"
    },
    "contracts/test-purposes/RelayMock.sol": {
      "content": "pragma solidity ^0.5.16;\n\nimport \"../LightGeneralizedTCR.sol\";\n\ncontract RelayMock {\n    function add(LightGeneralizedTCR _gtcr, string calldata _itemData)\n        external\n    {\n        _gtcr.addItemDirectly(_itemData);\n    }\n\n    function remove(LightGeneralizedTCR _gtcr, bytes32 _itemID) external {\n        _gtcr.removeItemDirectly(_itemID);\n    }\n}\n"
    },
    "contracts/utils/CappedMath.sol": {
      "content": "/**\n *  @authors: [@mtsalenc*]\n *  @reviewers: [@clesaege*]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity ^0.5.16;\n\n/**\n * @title CappedMath\n * @dev Math operations with caps for under and overflow.\n */\nlibrary CappedMath {\n    uint256 private constant UINT_MAX = 2**256 - 1;\n\n    /**\n     * @dev Adds two unsigned integers, returns 2^256 - 1 on overflow.\n     */\n    function addCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        return c >= _a ? c : UINT_MAX;\n    }\n\n    /**\n     * @dev Subtracts two integers, returns 0 on underflow.\n     */\n    function subCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        if (_b > _a) return 0;\n        else return _a - _b;\n    }\n\n    /**\n     * @dev Multiplies two unsigned integers, returns 2^256 - 1 on overflow.\n     */\n    function mulCap(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring '_a' not being zero, but the\n        // benefit is lost if '_b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) return 0;\n\n        uint256 c = _a * _b;\n        return c / _a == _b ? c : UINT_MAX;\n    }\n}\n"
    },
    "contracts/utils/CappedMath128.sol": {
      "content": "/**\n *  @authors: [@hbarcelos]\n *  @reviewers: [@fnanni-0]\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\npragma solidity ^0.5.16;\n\n/**\n * @title CappedMath\n * @dev Math operations with caps for under and overflow.\n */\nlibrary CappedMath128 {\n    uint128 private constant UINT128_MAX = 2**128 - 1;\n\n    /**\n     * @dev Adds two unsigned integers, returns 2^128 - 1 on overflow.\n     */\n    function addCap(uint128 _a, uint128 _b) internal pure returns (uint128) {\n        uint128 c = _a + _b;\n        return c >= _a ? c : UINT128_MAX;\n    }\n\n    /**\n     * @dev Subtracts two integers, returns 0 on underflow.\n     */\n    function subCap(uint128 _a, uint128 _b) internal pure returns (uint128) {\n        if (_b > _a) return 0;\n        else return _a - _b;\n    }\n\n    /**\n     * @dev Multiplies two unsigned integers, returns 2^128 - 1 on overflow.\n     */\n    function mulCap(uint128 _a, uint128 _b) internal pure returns (uint128) {\n        if (_a == 0) return 0;\n\n        uint128 c = _a * _b;\n        return c / _a == _b ? c : UINT128_MAX;\n    }\n}\n"
    },
    "contracts/view/GeneralizedTCRView.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport { GeneralizedTCR, IArbitrator } from \"../GeneralizedTCR.sol\";\nimport { BytesLib } from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport { RLPReader } from \"solidity-rlp/contracts/RLPReader.sol\";\n\n/* solium-disable max-len */\n/* solium-disable security/no-block-members */\n/* solium-disable security/no-send */ // It is the user responsibility to accept ETH.\n\n/**\n *  @title GeneralizedTCRView\n *  A view contract to fetch, batch, parse and return GTCR contract data efficiently.\n *  This contract includes functions that can halt execution due to out-of-gas exceptions. Because of this it should never be relied upon by other contracts.\n */\ncontract GeneralizedTCRView {\n    using RLPReader for RLPReader.RLPItem;\n    using RLPReader for bytes;\n    using BytesLib for bytes;\n\n    struct QueryResult {\n        bytes32 ID;\n        bytes data;\n        GeneralizedTCR.Status status;\n        bool disputed;\n        bool resolved;\n        uint disputeID;\n        uint appealCost;\n        bool appealed;\n        uint appealStart;\n        uint appealEnd;\n        GeneralizedTCR.Party ruling;\n        address requester;\n        address challenger;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        GeneralizedTCR.Party currentRuling;\n        bool[3] hasPaid;\n        uint feeRewards;\n        uint submissionTime;\n        uint[3] amountPaid;\n        IArbitrator.DisputeStatus disputeStatus;\n        uint numberOfRequests;\n    }\n\n    struct ArbitrableData {\n        address governor;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        uint submissionBaseDeposit;\n        uint removalBaseDeposit;\n        uint submissionChallengeBaseDeposit;\n        uint removalChallengeBaseDeposit;\n        uint challengePeriodDuration;\n        uint metaEvidenceUpdates;\n        uint winnerStakeMultiplier;\n        uint loserStakeMultiplier;\n        uint sharedStakeMultiplier;\n        uint MULTIPLIER_DIVISOR;\n        uint arbitrationCost;\n    }\n\n    /** @dev Fetch arbitrable TCR data in a single call.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @return The latest data on an arbitrable TCR contract.\n     */\n    function fetchArbitrable(address _address) external view returns (ArbitrableData memory result) {\n        GeneralizedTCR tcr = GeneralizedTCR(_address);\n        result.governor = tcr.governor();\n        result.arbitrator = address(tcr.arbitrator());\n        result.arbitratorExtraData = tcr.arbitratorExtraData();\n        result.submissionBaseDeposit = tcr.submissionBaseDeposit();\n        result.removalBaseDeposit = tcr.removalBaseDeposit();\n        result.submissionChallengeBaseDeposit = tcr.submissionChallengeBaseDeposit();\n        result.removalChallengeBaseDeposit = tcr.removalChallengeBaseDeposit();\n        result.challengePeriodDuration = tcr.challengePeriodDuration();\n        result.metaEvidenceUpdates = tcr.metaEvidenceUpdates();\n        result.winnerStakeMultiplier = tcr.winnerStakeMultiplier();\n        result.loserStakeMultiplier = tcr.loserStakeMultiplier();\n        result.sharedStakeMultiplier = tcr.sharedStakeMultiplier();\n        result.MULTIPLIER_DIVISOR = tcr.MULTIPLIER_DIVISOR();\n        result.arbitrationCost = IArbitrator(result.arbitrator).arbitrationCost(result.arbitratorExtraData);\n    }\n\n    /** @dev Fetch the latest data on an item in a single call.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The item data.\n     */\n    function getItem(address _address, bytes32 _itemID) public view returns (QueryResult memory result) {\n        RoundData memory round = getLatestRoundRequestData(_address, _itemID);\n        result = QueryResult({\n            ID: _itemID,\n            data: round.request.item.data,\n            status: round.request.item.status,\n            disputed: round.request.disputed,\n            resolved: round.request.resolved,\n            disputeID: round.request.disputeID,\n            appealCost: 0,\n            appealed: round.appealed,\n            appealStart: 0,\n            appealEnd: 0,\n            ruling: round.request.ruling,\n            requester: round.request.parties[uint(GeneralizedTCR.Party.Requester)],\n            challenger: round.request.parties[uint(GeneralizedTCR.Party.Challenger)],\n            arbitrator: address(round.request.arbitrator),\n            arbitratorExtraData: round.request.arbitratorExtraData,\n            currentRuling: GeneralizedTCR.Party.None,\n            hasPaid: round.hasPaid,\n            feeRewards: round.feeRewards,\n            submissionTime: round.request.submissionTime,\n            amountPaid: round.amountPaid,\n            disputeStatus: IArbitrator.DisputeStatus.Waiting,\n            numberOfRequests: round.request.item.numberOfRequests\n        });\n        if (round.request.disputed && round.request.arbitrator.disputeStatus(result.disputeID) == IArbitrator.DisputeStatus.Appealable) {\n            result.currentRuling = GeneralizedTCR.Party(round.request.arbitrator.currentRuling(result.disputeID));\n            result.disputeStatus = round.request.arbitrator.disputeStatus(result.disputeID);\n            (result.appealStart, result.appealEnd) = round.request.arbitrator.appealPeriod(result.disputeID);\n            result.appealCost = round.request.arbitrator.appealCost(result.disputeID, result.arbitratorExtraData);\n        }\n    }\n\n    struct ItemRequest {\n        bool disputed;\n        uint disputeID;\n        uint submissionTime;\n        bool resolved;\n        address requester;\n        address challenger;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        uint metaEvidenceID;\n    }\n\n    /** @dev Fetch all requests for an item.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The items requests.\n     */\n    function getItemRequests(address _address, bytes32 _itemID) external view returns (ItemRequest[] memory requests) {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        ItemData memory itemData = getItemData(_address, _itemID);\n        requests = new ItemRequest[](itemData.numberOfRequests);\n        for (uint i = 0; i < itemData.numberOfRequests; i++) {\n            (\n                bool disputed,\n                uint disputeID,\n                uint submissionTime,\n                bool resolved,\n                address payable[3] memory parties,\n                ,\n                ,\n                IArbitrator arbitrator,\n                bytes memory arbitratorExtraData,\n                uint metaEvidenceID\n            ) = gtcr.getRequestInfo(_itemID, i);\n\n            // Sort requests by newest first.\n            requests[itemData.numberOfRequests - i - 1] = ItemRequest({\n                disputed: disputed,\n                disputeID: disputeID,\n                submissionTime: submissionTime,\n                resolved: resolved,\n                requester: parties[uint(GeneralizedTCR.Party.Requester)],\n                challenger: parties[uint(GeneralizedTCR.Party.Challenger)],\n                arbitrator: address(arbitrator),\n                arbitratorExtraData: arbitratorExtraData,\n                metaEvidenceID: metaEvidenceID\n            });\n        }\n    }\n\n    /** @dev Find an item by matching column values exactly. Unless specified in the _ignoreColumns parameter, finding an item requires matching all columns.\n     *  - Example:\n     *  Item [18, 'PNK', 'Pinakion', '0xca35b7d915458ef540ade6068dfe2f44e8fa733c']\n     *  RLP encoded: 0xe383504e4b128850696e616b696f6e94ca35b7d915458ef540ade6068dfe2f44e8fa733c\n     *  Input for remix: [\"0xe3\",\"0x83\",\"0x50\",\"0x4e\",\"0x4b\",\"0x12\",\"0x88\",\"0x50\",\"0x69\",\"0x6e\",\"0x61\",\"0x6b\",\"0x69\",\"0x6f\",\"0x6e\",\"0x94\",\"0xca\",\"0x35\",\"0xb7\",\"0xd9\",\"0x15\",\"0x45\",\"0x8e\",\"0xf5\",\"0x40\",\"0xad\",\"0xe6\",\"0x06\",\"0x8d\",\"0xfe\",\"0x2f\",\"0x44\",\"0xe8\",\"0xfa\",\"0x73\",\"0x3c\"]\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _rlpEncodedMatch The RLP encoded item to match against the items on the list.\n     *  @param _cursor The index from where to start looking for matches.\n     *  @param _count The number of items to iterate and return while searching.\n     *  @param _skipState Boolean tuple defining whether to skip items in a given state. [Absent, Registered, RegistrationRequested, ClearingRequested].\n     *  @param _ignoreColumns Columns to ignore when searching. If this is an array with only false items, then every column must match exactly.\n     *  @return An array with items that match the query.\n     */\n    function findItem(\n        address _address,\n        bytes memory _rlpEncodedMatch,\n        uint _cursor,\n        uint _count,\n        bool[4] memory _skipState,\n        bool[] memory _ignoreColumns\n    )\n        public\n        view\n        returns (QueryResult[] memory results)\n    {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        RLPReader.RLPItem[] memory matchItem = _rlpEncodedMatch.toRlpItem().toList();\n        results = new QueryResult[](_count == 0 ? gtcr.itemCount() : _count);\n        uint itemsFound;\n\n        for(uint i = _cursor; i < (_count == 0 ? gtcr.itemCount() : _count); i++) { // Iterate over every item in storage.\n            QueryResult memory item = getItem(_address, gtcr.itemList(i));\n            if (_skipState[uint(item.status)])\n                continue;\n\n            RLPReader.RLPItem[] memory itemData = item.data.toRlpItem().toList();\n            bool itemFound = true;\n            for (uint j = 0; j < matchItem.length; j++) { // Iterate over every column.\n                if (!_ignoreColumns[j] && !itemData[j].toBytes().equal(matchItem[j].toBytes())) {\n                    // This column should not be ignored and it did not match input. Item not found.\n                    itemFound = false;\n                    break;\n                }\n            }\n\n            // All not ignored columns matched, item found. Add it\n            if (itemFound) {\n                results[itemsFound] = item;\n                itemsFound++;\n            }\n        }\n\n        return results;\n    }\n\n    /** @dev Find the index of the first item of a page of items for a given filter.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _targets The targets to use for the query. Each element of the array in sequence means:\n     *  - The page to search;\n     *  - The number of items per page;\n     *  - The number of items to iterate when searching;\n     *  - The position from where to start iterating.\n     *  @param _filter The filter to use. Each element of the array in sequence means:\n     *  - Include absent items in result;\n     *  - Include registered items in result;\n     *  - Include items with registration requests that are not disputed in result;\n     *  - Include items with clearing requests that are not disputed in result;\n     *  - Include disputed items with registration requests in result;\n     *  - Include disputed items with clearing requests in result;\n     *  - Include items with a request by _party;\n     *  - Include items challenged by _party.\n     *  - Whether to sort from oldest to the newest item.\n     *  @param _party The address to use if checking for items with a request or challenged by a specific party.\n     *  @return The query result:\n     *  - Index of the page, if it was found;\n     *  - Whether there are more items to iterate;\n     *  - If the index of the page we are searching was found.\n     */\n    function findIndexForPage(\n        address _address,\n        uint[4] calldata _targets,\n        bool[9] calldata _filter,\n        address _party\n    )\n        external\n        view\n        returns (uint index, bool hasMore, bool indexFound)\n    {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        uint count = _targets[2];\n        uint currPage = 1;\n        uint itemsMatched = 0;\n\n        if (gtcr.itemCount() == 0) return (0, false, true);\n\n        // Start iterating from the end if the _cursorIndex is 0 and _oldestFirst is false.\n        // Keep the cursor as is otherwise.\n        uint i = _filter[8] ? _targets[3] : _targets[3] == 0 ? gtcr.itemCount() - 1 : _targets[3];\n\n        for(; _filter[8] ? i < gtcr.itemCount() && count > 0 : i >= 0 && count > 0; ) {\n            bytes32 itemID = gtcr.itemList(i);\n            QueryResult memory item = getItem(_address, itemID);\n            hasMore = true;\n            if (\n                (_filter[0] && item.status == GeneralizedTCR.Status.Absent) ||\n                (_filter[1] && item.status == GeneralizedTCR.Status.Registered) ||\n                (_filter[2] && item.status == GeneralizedTCR.Status.RegistrationRequested && !item.disputed) ||\n                (_filter[3] && item.status == GeneralizedTCR.Status.ClearingRequested && !item.disputed) ||\n                (_filter[4] && item.status == GeneralizedTCR.Status.RegistrationRequested && item.disputed) ||\n                (_filter[5] && item.status == GeneralizedTCR.Status.ClearingRequested && item.disputed) ||\n                (_filter[6] && item.requester == _party) ||\n                (_filter[7] && item.challenger == _party)\n            ) {\n                itemsMatched++;\n                if (itemsMatched % _targets[1] == 0) {\n                    currPage++;\n                    if (currPage == _targets[0]){\n                        if ((i == 0 && !_filter[8]) || (i == gtcr.itemCount() - 1 && _filter[8])) hasMore = false;\n                        return (_filter[8] ? i + 1 : i - 1, hasMore, true);\n                    }\n                }\n            }\n            count--;\n            if (count == 0 || (i == 0 && !_filter[8]) || (i == gtcr.itemCount() - 1 && _filter[8])) {\n                hasMore = _filter[8] ? i < gtcr.itemCount() : i > 0;\n                break;\n            }\n            // Move cursor to the left or right depending on _oldestFirst.\n            // Also prevents underflow if the cursor is at the first item.\n            i = _filter[8] ? i + 1 : i == 0 ? 0 : i - 1;\n        }\n\n        // If sorting by oldest first, and not enough items were found to fill a page, return the cursor index.\n        if (_filter[8] && _targets[3] + _targets[1] > _targets[3] + i) {\n            i = _targets[3];\n        }\n        return (i, hasMore, false);\n    }\n\n    /** @dev Count the number of items for a given filter.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _cursorIndex The index of the items from which to start iterating. To start from either the oldest or newest item.\n     *  @param _count The number of items to return.\n     *  @param _filter The filter to use. Each element of the array in sequence means:\n     *  - Include absent items in result;\n     *  - Include registered items in result;\n     *  - Include items with registration requests that are not disputed in result;\n     *  - Include items with clearing requests that are not disputed in result;\n     *  - Include disputed items with registration requests in result;\n     *  - Include disputed items with clearing requests in result;\n     *  - Include items with a request by _party;\n     *  - Include items challenged by _party.\n     *  @param _party The address to use if checking for items with a request or challenged by a specific party.\n     *  @return The query result:\n     *  - The number of items found for the filter;\n     *  - Whether there are more items to iterate;\n     *  - The index of the last item of the query. Useful as a starting point for the next query if counting in multiple steps.\n     */\n    function countWithFilter(address _address, uint _cursorIndex, uint _count, bool[8] calldata _filter, address _party)\n        external\n        view\n        returns (uint count, bool hasMore, uint)\n    {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        if (gtcr.itemCount() == 0) return (0, false, 0);\n\n        uint iterations = 0;\n        for (uint i = _cursorIndex; iterations <= _count && i < gtcr.itemCount(); i++) {\n            bytes32 itemID = gtcr.itemList(i);\n            QueryResult memory item = getItem(_address, itemID);\n            if (\n                (_filter[0] && item.status == GeneralizedTCR.Status.Absent) ||\n                (_filter[1] && item.status == GeneralizedTCR.Status.Registered) ||\n                (_filter[2] && item.status == GeneralizedTCR.Status.RegistrationRequested && !item.disputed) ||\n                (_filter[3] && item.status == GeneralizedTCR.Status.ClearingRequested && !item.disputed) ||\n                (_filter[4] && item.status == GeneralizedTCR.Status.RegistrationRequested && item.disputed) ||\n                (_filter[5] && item.status == GeneralizedTCR.Status.ClearingRequested && item.disputed) ||\n                (_filter[6] && item.requester == _party) ||\n                (_filter[7] && item.challenger == _party)\n            ) {\n                count++;\n                if (iterations >= _count) {\n                    return (count, true, i);\n                }\n            }\n            iterations++;\n        }\n    }\n\n    /** @dev Return the values of the items the query finds. This function is O(n), where n is the number of items. This could exceed the gas limit, therefore this function should only be used for interface display and not by other contracts.\n     *  @param _address The address of the GTCR to query.\n     *  @param _cursorIndex The index of the items from which to start iterating. To start from either the oldest or newest item.\n     *  @param _count The number of items to iterate.\n     *  @param _filter The filter to use. Each element of the array in sequence means:\n     *  - Include absent items in result;\n     *  - Include registered items in result;\n     *  - Include items with registration requests that are not disputed in result;\n     *  - Include items with clearing requests that are not disputed in result;\n     *  - Include disputed items with registration requests in result;\n     *  - Include disputed items with clearing requests in result;\n     *  - Include items with a request by _party;\n     *  - Include items challenged by _party.\n     *  @param _oldestFirst Whether to sort from oldest to the newest item.\n     *  @param _party The address to use if checking for items with a request or challenged by a specific party.\n     *  @param _limit The maximum number of items to return. If set to 0 will return _count items.\n     *  @return The data of the items found and whether there are more items for the current filter and sort.\n     */\n    function queryItems(\n        address _address,\n        uint _cursorIndex,\n        uint _count,\n        bool[8] calldata _filter,\n        bool _oldestFirst,\n        address _party,\n        uint _limit\n    )\n        external\n        view\n        returns (QueryResult[] memory results, bool hasMore)\n    {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        results = new QueryResult[](_count);\n        uint index = 0;\n        uint count = _count;\n        if (_limit == 0) _limit = count;\n\n        if (gtcr.itemCount() == 0) return (results, false);\n\n        // Start iterating from the end if the _cursorIndex is 0 and _oldestFirst is false.\n        // Keep the cursor as is otherwise.\n        uint i = _oldestFirst ? _cursorIndex : _cursorIndex == 0 ? gtcr.itemCount() - 1 : _cursorIndex;\n\n        for(; _oldestFirst ? i < gtcr.itemCount() && count > 0 : i >= 0 && count > 0; ) {\n            bytes32 itemID = gtcr.itemList(i);\n            QueryResult memory item = getItem(_address, itemID);\n            hasMore = true;\n            if (\n                (_filter[0] && item.status == GeneralizedTCR.Status.Absent) ||\n                (_filter[1] && item.status == GeneralizedTCR.Status.Registered) ||\n                (_filter[2] && item.status == GeneralizedTCR.Status.RegistrationRequested && !item.disputed) ||\n                (_filter[3] && item.status == GeneralizedTCR.Status.ClearingRequested && !item.disputed) ||\n                (_filter[4] && item.status == GeneralizedTCR.Status.RegistrationRequested && item.disputed) ||\n                (_filter[5] && item.status == GeneralizedTCR.Status.ClearingRequested && item.disputed) ||\n                (_filter[6] && item.requester == _party) ||\n                (_filter[7] && item.challenger == _party)\n            ) {\n                results[index] = item;\n                index++;\n                if (index == _limit) break;\n            }\n            count--;\n            if (count == 0 || (i == 0 && !_oldestFirst) || (i == gtcr.itemCount() - 1 && _oldestFirst)) {\n                hasMore = _oldestFirst ? i < gtcr.itemCount() - 1 : i > 0;\n                break;\n            }\n            // Move cursor to the left or right depending on _oldestFirst.\n            // Also prevents underflow if the cursor is at the first item.\n            i = _oldestFirst ? i + 1 : i == 0 ? 0 : i - 1;\n        }\n    }\n\n    /** @dev Return the withdrawable rewards for a contributor.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @param _contributor The address of the contributor.\n     *  @return The amount withdrawable per round per request.\n     */\n    function availableRewards(address _address, bytes32 _itemID, address _contributor) external view returns (uint rewards) {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n\n        // Using arrays to avoid stack limit.\n        uint[2] memory requestRoundCount = [uint(0), uint(0)];\n        uint[2] memory indexes = [uint(0), uint(0)]; // Request index and round index.\n\n        (,,requestRoundCount[0]) = gtcr.getItemInfo(_itemID);\n        for (indexes[0]; indexes[0] < requestRoundCount[0]; indexes[0]++) {\n            GeneralizedTCR.Party ruling;\n            bool resolved;\n            (,,, resolved,, requestRoundCount[1], ruling,,,) = gtcr.getRequestInfo(_itemID, indexes[0]);\n            if (!resolved) continue;\n            for (indexes[1]; indexes[1] < requestRoundCount[1]; indexes[1]++) {\n                (\n                    ,\n                    uint[3] memory amountPaid,\n                    bool[3] memory hasPaid,\n                    uint feeRewards\n                ) = gtcr.getRoundInfo(_itemID, indexes[0], indexes[1]);\n\n                uint[3] memory roundContributions = gtcr.getContributions(_itemID, indexes[0], indexes[1], _contributor);\n                if (!hasPaid[uint(GeneralizedTCR.Party.Requester)] || !hasPaid[uint(GeneralizedTCR.Party.Challenger)]) {\n                    // Amount reimbursable if not enough fees were raised to appeal the ruling.\n                    rewards += roundContributions[uint(GeneralizedTCR.Party.Requester)] + roundContributions[uint(GeneralizedTCR.Party.Challenger)];\n                } else if (ruling == GeneralizedTCR.Party.None) {\n                    // Reimbursable fees proportional if there aren't a winner and loser.\n                    rewards += amountPaid[uint(GeneralizedTCR.Party.Requester)] > 0\n                        ? (roundContributions[uint(GeneralizedTCR.Party.Requester)] * feeRewards) / (amountPaid[uint(GeneralizedTCR.Party.Challenger)] + amountPaid[uint(GeneralizedTCR.Party.Requester)])\n                        : 0;\n                    rewards += amountPaid[uint(GeneralizedTCR.Party.Challenger)] > 0\n                        ? (roundContributions[uint(GeneralizedTCR.Party.Challenger)] * feeRewards) / (amountPaid[uint(GeneralizedTCR.Party.Challenger)] + amountPaid[uint(GeneralizedTCR.Party.Requester)])\n                        : 0;\n                } else {\n                    // Contributors to the winner take the rewards.\n                    rewards += amountPaid[uint(ruling)] > 0\n                        ? (roundContributions[uint(ruling)] * feeRewards) / amountPaid[uint(ruling)]\n                        : 0;\n                }\n            }\n            indexes[1] = 0;\n        }\n    }\n\n\n    // Functions and structs below used mainly to avoid stack limit.\n    struct ItemData {\n        bytes data;\n        GeneralizedTCR.Status status;\n        uint numberOfRequests;\n    }\n\n    struct RequestData {\n        ItemData item;\n        bool disputed;\n        uint disputeID;\n        uint submissionTime;\n        bool resolved;\n        address payable[3] parties;\n        uint numberOfRounds;\n        GeneralizedTCR.Party ruling;\n        IArbitrator arbitrator;\n        bytes arbitratorExtraData;\n    }\n\n    struct RoundData {\n        RequestData request;\n        bool appealed;\n        uint[3] amountPaid;\n        bool[3] hasPaid;\n        uint feeRewards;\n    }\n\n    /** @dev Fetch data of the an item and return a struct.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getItemData(address _address, bytes32 _itemID) public view returns(ItemData memory item) {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        (\n            bytes memory data,\n            GeneralizedTCR.Status status,\n            uint numberOfRequests\n        ) = gtcr.getItemInfo(_itemID);\n        item = ItemData(data, status, numberOfRequests);\n    }\n\n    /** @dev Fetch the latest request of item.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getLatestRequestData(address _address, bytes32 _itemID) public view returns (RequestData memory request)  {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        ItemData memory item = getItemData(_address, _itemID);\n        (\n            bool disputed,\n            uint disputeID,\n            uint submissionTime,\n            bool resolved,\n            address payable[3] memory parties,\n            uint numberOfRounds,\n            GeneralizedTCR.Party ruling,\n            IArbitrator arbitrator,\n            bytes memory arbitratorExtraData,\n        ) = gtcr.getRequestInfo(_itemID, item.numberOfRequests - 1);\n        request = RequestData(\n            item,\n            disputed,\n            disputeID,\n            submissionTime,\n            resolved,\n            parties,\n            numberOfRounds,\n            ruling,\n            arbitrator,\n            arbitratorExtraData\n        );\n    }\n\n    /** @dev Fetch the latest round of the latest request of an item.\n     *  @param _address The address of the Generalized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getLatestRoundRequestData(address _address, bytes32 _itemID) public view returns (RoundData memory round)  {\n        GeneralizedTCR gtcr = GeneralizedTCR(_address);\n        RequestData memory request = getLatestRequestData(_address, _itemID);\n        (\n            bool appealed,\n            uint[3] memory amountPaid,\n            bool[3] memory hasPaid,\n            uint feeRewards\n        ) = gtcr.getRoundInfo(_itemID, request.item.numberOfRequests - 1, request.numberOfRounds - 1);\n        round = RoundData(\n            request,\n            appealed,\n            amountPaid,\n            hasPaid,\n            feeRewards\n        );\n    }\n}\n"
    },
    "contracts/view/LightGeneralizedTCRView.sol": {
      "content": "/**\n *  @authors: [@mtsalenc]\n *  @reviewers: []\n *  @auditors: []\n *  @bounties: []\n *  @deployments: []\n */\n\npragma solidity 0.5.17;\npragma experimental ABIEncoderV2;\n\nimport {LightGeneralizedTCR, IArbitrator} from \"../LightGeneralizedTCR.sol\";\n\n/* solium-disable max-len */\n/* solium-disable security/no-block-members */\n/* solium-disable security/no-send */\n// It is the user responsibility to accept ETH.\n\n/**\n *  @title LightGeneralizedTCRView\n *  A view contract to fetch, batch, parse and return GTCR contract data efficiently.\n *  This contract includes functions that can halt execution due to out-of-gas exceptions. Because of this it should never be relied upon by other contracts.\n */\ncontract LightGeneralizedTCRView {\n    struct QueryResult {\n        bytes32 ID;\n        LightGeneralizedTCR.Status status;\n        bool disputed;\n        bool resolved;\n        uint256 disputeID;\n        uint256 appealCost;\n        bool appealed;\n        uint256 appealStart;\n        uint256 appealEnd;\n        LightGeneralizedTCR.Party ruling;\n        address requester;\n        address challenger;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        LightGeneralizedTCR.Party currentRuling;\n        bool[3] hasPaid;\n        uint256 feeRewards;\n        uint256 submissionTime;\n        uint256[3] amountPaid;\n        IArbitrator.DisputeStatus disputeStatus;\n        uint256 numberOfRequests;\n    }\n\n    struct ArbitrableData {\n        address governor;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        uint256 submissionBaseDeposit;\n        uint256 removalBaseDeposit;\n        uint256 submissionChallengeBaseDeposit;\n        uint256 removalChallengeBaseDeposit;\n        uint256 challengePeriodDuration;\n        uint256 metaEvidenceUpdates;\n        uint256 winnerStakeMultiplier;\n        uint256 loserStakeMultiplier;\n        uint256 sharedStakeMultiplier;\n        uint256 MULTIPLIER_DIVISOR;\n        uint256 arbitrationCost;\n    }\n\n    /** @dev Fetch arbitrable TCR data in a single call.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @return The latest data on an arbitrable TCR contract.\n     */\n    function fetchArbitrable(address _address) external view returns (ArbitrableData memory result) {\n        LightGeneralizedTCR tcr = LightGeneralizedTCR(_address);\n        result.governor = tcr.governor();\n        result.arbitrator = address(tcr.arbitrator());\n        result.arbitratorExtraData = tcr.arbitratorExtraData();\n        result.submissionBaseDeposit = tcr.submissionBaseDeposit();\n        result.removalBaseDeposit = tcr.removalBaseDeposit();\n        result.submissionChallengeBaseDeposit = tcr.submissionChallengeBaseDeposit();\n        result.removalChallengeBaseDeposit = tcr.removalChallengeBaseDeposit();\n        result.challengePeriodDuration = tcr.challengePeriodDuration();\n        result.metaEvidenceUpdates = tcr.metaEvidenceUpdates();\n        result.winnerStakeMultiplier = tcr.winnerStakeMultiplier();\n        result.loserStakeMultiplier = tcr.loserStakeMultiplier();\n        result.sharedStakeMultiplier = tcr.sharedStakeMultiplier();\n        result.MULTIPLIER_DIVISOR = tcr.MULTIPLIER_DIVISOR();\n        result.arbitrationCost = IArbitrator(result.arbitrator).arbitrationCost(result.arbitratorExtraData);\n    }\n\n    /** @dev Fetch the latest data on an item in a single call.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The item data.\n     */\n    function getItem(address _address, bytes32 _itemID) public view returns (QueryResult memory result) {\n        RoundData memory round = getLatestRoundRequestData(_address, _itemID);\n        result = QueryResult({\n            ID: _itemID,\n            status: round.request.item.status,\n            disputed: round.request.disputed,\n            resolved: round.request.resolved,\n            disputeID: round.request.disputeID,\n            appealCost: 0,\n            appealed: round.appealed,\n            appealStart: 0,\n            appealEnd: 0,\n            ruling: round.request.ruling,\n            requester: round.request.parties[uint256(LightGeneralizedTCR.Party.Requester)],\n            challenger: round.request.parties[uint256(LightGeneralizedTCR.Party.Challenger)],\n            arbitrator: address(round.request.arbitrator),\n            arbitratorExtraData: round.request.arbitratorExtraData,\n            currentRuling: LightGeneralizedTCR.Party.None,\n            hasPaid: round.hasPaid,\n            feeRewards: round.feeRewards,\n            submissionTime: round.request.submissionTime,\n            amountPaid: round.amountPaid,\n            disputeStatus: IArbitrator.DisputeStatus.Waiting,\n            numberOfRequests: round.request.item.numberOfRequests\n        });\n        if (\n            round.request.disputed &&\n            round.request.arbitrator.disputeStatus(result.disputeID) == IArbitrator.DisputeStatus.Appealable\n        ) {\n            result.currentRuling = LightGeneralizedTCR.Party(round.request.arbitrator.currentRuling(result.disputeID));\n            result.disputeStatus = round.request.arbitrator.disputeStatus(result.disputeID);\n            (result.appealStart, result.appealEnd) = round.request.arbitrator.appealPeriod(result.disputeID);\n            result.appealCost = round.request.arbitrator.appealCost(result.disputeID, result.arbitratorExtraData);\n        }\n    }\n\n    struct ItemRequest {\n        bool disputed;\n        uint256 disputeID;\n        uint256 submissionTime;\n        bool resolved;\n        address requester;\n        address challenger;\n        address arbitrator;\n        bytes arbitratorExtraData;\n        uint256 metaEvidenceID;\n    }\n\n    /** @dev Fetch all requests for an item.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The items requests.\n     */\n    function getItemRequests(address _address, bytes32 _itemID) external view returns (ItemRequest[] memory requests) {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        ItemData memory itemData = getItemData(_address, _itemID);\n        requests = new ItemRequest[](itemData.numberOfRequests);\n        for (uint256 i = 0; i < itemData.numberOfRequests; i++) {\n            (\n                bool disputed,\n                uint256 disputeID,\n                uint256 submissionTime,\n                bool resolved,\n                address payable[3] memory parties,\n                ,\n                ,\n                IArbitrator arbitrator,\n                bytes memory arbitratorExtraData,\n                uint256 metaEvidenceID\n            ) = gtcr.getRequestInfo(_itemID, i);\n\n            // Sort requests by newest first.\n            requests[itemData.numberOfRequests - i - 1] = ItemRequest({\n                disputed: disputed,\n                disputeID: disputeID,\n                submissionTime: submissionTime,\n                resolved: resolved,\n                requester: parties[uint256(LightGeneralizedTCR.Party.Requester)],\n                challenger: parties[uint256(LightGeneralizedTCR.Party.Challenger)],\n                arbitrator: address(arbitrator),\n                arbitratorExtraData: arbitratorExtraData,\n                metaEvidenceID: metaEvidenceID\n            });\n        }\n    }\n\n    /** @dev Return the withdrawable rewards for a contributor.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @param _contributor The address of the contributor.\n     *  @return The amount withdrawable per round per request.\n     */\n    function availableRewards(\n        address _address,\n        bytes32 _itemID,\n        address _contributor\n    ) external view returns (uint256 rewards) {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n\n        // Using arrays to avoid stack limit.\n        uint256[2] memory requestRoundCount = [uint256(0), uint256(0)];\n        uint256[2] memory indexes = [uint256(0), uint256(0)]; // Request index and round index.\n\n        (, requestRoundCount[0], ) = gtcr.getItemInfo(_itemID);\n        for (indexes[0]; indexes[0] < requestRoundCount[0]; indexes[0]++) {\n            LightGeneralizedTCR.Party ruling;\n            bool resolved;\n            (, , , resolved, , requestRoundCount[1], ruling, , , ) = gtcr.getRequestInfo(_itemID, indexes[0]);\n            if (!resolved) continue;\n            for (indexes[1]; indexes[1] < requestRoundCount[1]; indexes[1]++) {\n                (, uint256[3] memory amountPaid, bool[3] memory hasPaid, uint256 feeRewards) = gtcr.getRoundInfo(\n                    _itemID,\n                    indexes[0],\n                    indexes[1]\n                );\n\n                uint256[3] memory roundContributions = gtcr.getContributions(\n                    _itemID,\n                    indexes[0],\n                    indexes[1],\n                    _contributor\n                );\n                if (\n                    !hasPaid[uint256(LightGeneralizedTCR.Party.Requester)] ||\n                    !hasPaid[uint256(LightGeneralizedTCR.Party.Challenger)]\n                ) {\n                    // Amount reimbursable if not enough fees were raised to appeal the ruling.\n                    rewards +=\n                        roundContributions[uint256(LightGeneralizedTCR.Party.Requester)] +\n                        roundContributions[uint256(LightGeneralizedTCR.Party.Challenger)];\n                } else if (ruling == LightGeneralizedTCR.Party.None) {\n                    // Reimbursable fees proportional if there aren't a winner and loser.\n                    rewards += amountPaid[uint256(LightGeneralizedTCR.Party.Requester)] > 0\n                        ? (roundContributions[uint256(LightGeneralizedTCR.Party.Requester)] * feeRewards) /\n                            (amountPaid[uint256(LightGeneralizedTCR.Party.Challenger)] +\n                                amountPaid[uint256(LightGeneralizedTCR.Party.Requester)])\n                        : 0;\n                    rewards += amountPaid[uint256(LightGeneralizedTCR.Party.Challenger)] > 0\n                        ? (roundContributions[uint256(LightGeneralizedTCR.Party.Challenger)] * feeRewards) /\n                            (amountPaid[uint256(LightGeneralizedTCR.Party.Challenger)] +\n                                amountPaid[uint256(LightGeneralizedTCR.Party.Requester)])\n                        : 0;\n                } else {\n                    // Contributors to the winner take the rewards.\n                    rewards += amountPaid[uint256(ruling)] > 0\n                        ? (roundContributions[uint256(ruling)] * feeRewards) / amountPaid[uint256(ruling)]\n                        : 0;\n                }\n            }\n            indexes[1] = 0;\n        }\n    }\n\n    // Functions and structs below used mainly to avoid stack limit.\n    struct ItemData {\n        LightGeneralizedTCR.Status status;\n        uint256 numberOfRequests;\n    }\n\n    struct RequestData {\n        ItemData item;\n        bool disputed;\n        uint256 disputeID;\n        uint256 submissionTime;\n        bool resolved;\n        address payable[3] parties;\n        uint256 numberOfRounds;\n        LightGeneralizedTCR.Party ruling;\n        IArbitrator arbitrator;\n        bytes arbitratorExtraData;\n    }\n\n    struct RoundData {\n        RequestData request;\n        bool appealed;\n        uint256[3] amountPaid;\n        bool[3] hasPaid;\n        uint256 feeRewards;\n    }\n\n    /** @dev Fetch data of the an item and return a struct.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getItemData(address _address, bytes32 _itemID) public view returns (ItemData memory item) {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        (LightGeneralizedTCR.Status status, uint256 numberOfRequests, ) = gtcr.getItemInfo(_itemID);\n        item = ItemData(status, numberOfRequests);\n    }\n\n    /** @dev Fetch the latest request of item.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getLatestRequestData(address _address, bytes32 _itemID) public view returns (RequestData memory request) {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        ItemData memory item = getItemData(_address, _itemID);\n        (\n            bool disputed,\n            uint256 disputeID,\n            uint256 submissionTime,\n            bool resolved,\n            address payable[3] memory parties,\n            uint256 numberOfRounds,\n            LightGeneralizedTCR.Party ruling,\n            IArbitrator arbitrator,\n            bytes memory arbitratorExtraData,\n\n        ) = gtcr.getRequestInfo(_itemID, item.numberOfRequests - 1);\n        request = RequestData(\n            item,\n            disputed,\n            disputeID,\n            submissionTime,\n            resolved,\n            parties,\n            numberOfRounds,\n            ruling,\n            arbitrator,\n            arbitratorExtraData\n        );\n    }\n\n    /** @dev Fetch the latest round of the latest request of an item.\n     *  @param _address The address of the LightGeneralized TCR to query.\n     *  @param _itemID The ID of the item to query.\n     *  @return The round data.\n     */\n    function getLatestRoundRequestData(address _address, bytes32 _itemID) public view returns (RoundData memory round) {\n        LightGeneralizedTCR gtcr = LightGeneralizedTCR(_address);\n        (, , uint256 sumDeposit) = gtcr.getItemInfo(_itemID);\n        RequestData memory request = getLatestRequestData(_address, _itemID);\n\n        if (request.disputed) {\n            (bool appealed, uint256[3] memory amountPaid, bool[3] memory hasPaid, uint256 feeRewards) = gtcr\n                .getRoundInfo(_itemID, request.item.numberOfRequests - 1, request.numberOfRounds - 1);\n\n            round = RoundData(request, appealed, amountPaid, hasPaid, feeRewards);\n        } else {\n            round = RoundData(request, false, [0, sumDeposit, 0], [false, true, false], sumDeposit);\n        }\n    }\n}\n"
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "/*\n * @title Solidity Bytes Arrays Utils\n * @author Gon√ßalo S√° <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\n\npragma solidity ^0.5.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add \n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes_slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes_slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes_slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n                \n                for { \n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_bytes.length >= (_start + _length));\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal  pure returns (address) {\n        require(_bytes.length >= (_start + 20));\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal  pure returns (uint8) {\n        require(_bytes.length >= (_start + 1));\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal  pure returns (uint16) {\n        require(_bytes.length >= (_start + 2));\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal  pure returns (uint32) {\n        require(_bytes.length >= (_start + 4));\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal  pure returns (uint64) {\n        require(_bytes.length >= (_start + 8));\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal  pure returns (uint96) {\n        require(_bytes.length >= (_start + 12));\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal  pure returns (uint128) {\n        require(_bytes.length >= (_start + 16));\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint(bytes memory _bytes, uint _start) internal  pure returns (uint256) {\n        require(_bytes.length >= (_start + 32));\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal  pure returns (bytes32) {\n        require(_bytes.length >= (_start + 32));\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes_slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes_slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "solidity-rlp/contracts/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n* @author Hamdi Allam hamdi.allam97@gmail.com\n* Please reach out with any questions or concerns\n*/\npragma solidity >=0.5.0 <0.7.0;\n\nlibrary RLPReader {\n    uint8 constant STRING_SHORT_START = 0x80;\n    uint8 constant STRING_LONG_START  = 0xb8;\n    uint8 constant LIST_SHORT_START   = 0xc0;\n    uint8 constant LIST_LONG_START    = 0xf8;\n    uint8 constant WORD_SIZE = 32;\n\n    struct RLPItem {\n        uint len;\n        uint memPtr;\n    }\n\n    struct Iterator {\n        RLPItem item;   // Item that's being iterated over.\n        uint nextPtr;   // Position of the next item in the list.\n    }\n\n    /*\n    * @dev Returns the next element in the iteration. Reverts if it has not next element.\n    * @param self The iterator.\n    * @return The next element in the iteration.\n    */\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\n        require(hasNext(self));\n\n        uint ptr = self.nextPtr;\n        uint itemLength = _itemLength(ptr);\n        self.nextPtr = ptr + itemLength;\n\n        return RLPItem(itemLength, ptr);\n    }\n\n    /*\n    * @dev Returns true if the iteration has more elements.\n    * @param self The iterator.\n    * @return true if the iteration has more elements.\n    */\n    function hasNext(Iterator memory self) internal pure returns (bool) {\n        RLPItem memory item = self.item;\n        return self.nextPtr < item.memPtr + item.len;\n    }\n\n    /*\n    * @param item RLP encoded bytes\n    */\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n        uint memPtr;\n        assembly {\n            memPtr := add(item, 0x20)\n        }\n\n        return RLPItem(item.length, memPtr);\n    }\n\n    /*\n    * @dev Create an iterator. Reverts if item is not a list.\n    * @param self The RLP item.\n    * @return An 'Iterator' over the item.\n    */\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\n        require(isList(self));\n\n        uint ptr = self.memPtr + _payloadOffset(self.memPtr);\n        return Iterator(self, ptr);\n    }\n\n    /*\n    * @param the RLP item.\n    */\n    function rlpLen(RLPItem memory item) internal pure returns (uint) {\n        return item.len;\n    }\n\n    /*\n     * @param the RLP item.\n     * @return (memPtr, len) pair: location of the item's payload in memory.\n     */\n    function payloadLocation(RLPItem memory item) internal pure returns (uint, uint) {\n        uint offset = _payloadOffset(item.memPtr);\n        uint memPtr = item.memPtr + offset;\n        uint len = item.len - offset; // data length\n        return (memPtr, len);\n    }\n\n    /*\n    * @param the RLP item.\n    */\n    function payloadLen(RLPItem memory item) internal pure returns (uint) {\n        (, uint len) = payloadLocation(item);\n        return len;\n    }\n\n    /*\n    * @param the RLP item containing the encoded list.\n    */\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\n        require(isList(item));\n\n        uint items = numItems(item);\n        RLPItem[] memory result = new RLPItem[](items);\n\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint dataLen;\n        for (uint i = 0; i < items; i++) {\n            dataLen = _itemLength(memPtr);\n            result[i] = RLPItem(dataLen, memPtr); \n            memPtr = memPtr + dataLen;\n        }\n\n        return result;\n    }\n\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\n    function isList(RLPItem memory item) internal pure returns (bool) {\n        if (item.len == 0) return false;\n\n        uint8 byte0;\n        uint memPtr = item.memPtr;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < LIST_SHORT_START)\n            return false;\n        return true;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of RLP encoded bytes.\n     */\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        uint256 ptr = item.memPtr;\n        uint256 len = item.len;\n        bytes32 result;\n        assembly {\n            result := keccak256(ptr, len)\n        }\n        return result;\n    }\n\n    /*\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n     * @return keccak256 hash of the item payload.\n     */\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\n        (uint memPtr, uint len) = payloadLocation(item);\n        bytes32 result;\n        assembly {\n            result := keccak256(memPtr, len)\n        }\n        return result;\n    }\n\n    /** RLPItem conversions into data types **/\n\n    // @returns raw rlp encoding in bytes\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        bytes memory result = new bytes(item.len);\n        if (result.length == 0) return result;\n        \n        uint ptr;\n        assembly {\n            ptr := add(0x20, result)\n        }\n\n        copy(item.memPtr, ptr, item.len);\n        return result;\n    }\n\n    // any non-zero byte except \"0x80\" is considered true\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\n        require(item.len == 1);\n        uint result;\n        uint memPtr = item.memPtr;\n        assembly {\n            result := byte(0, mload(memPtr))\n        }\n\n        // SEE Github Issue #5.\n        // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n        // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n        // here.\n        if (result == 0 || result == STRING_SHORT_START) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function toAddress(RLPItem memory item) internal pure returns (address) {\n        // 1 byte for the length prefix\n        require(item.len == 21);\n\n        return address(toUint(item));\n    }\n\n    function toUint(RLPItem memory item) internal pure returns (uint) {\n        require(item.len > 0 && item.len <= 33);\n\n        (uint memPtr, uint len) = payloadLocation(item);\n\n        uint result;\n        assembly {\n            result := mload(memPtr)\n\n            // shfit to the correct location if neccesary\n            if lt(len, 32) {\n                result := div(result, exp(256, sub(32, len)))\n            }\n        }\n\n        return result;\n    }\n\n    // enforces 32 byte length\n    function toUintStrict(RLPItem memory item) internal pure returns (uint) {\n        // one byte prefix\n        require(item.len == 33);\n\n        uint result;\n        uint memPtr = item.memPtr + 1;\n        assembly {\n            result := mload(memPtr)\n        }\n\n        return result;\n    }\n\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n        require(item.len > 0);\n\n        (uint memPtr, uint len) = payloadLocation(item);\n        bytes memory result = new bytes(len);\n\n        uint destPtr;\n        assembly {\n            destPtr := add(0x20, result)\n        }\n\n        copy(memPtr, destPtr, len);\n        return result;\n    }\n\n    /*\n    * Private Helpers\n    */\n\n    // @return number of payload items inside an encoded list.\n    function numItems(RLPItem memory item) private pure returns (uint) {\n        if (item.len == 0) return 0;\n\n        uint count = 0;\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\n        uint endPtr = item.memPtr + item.len;\n        while (currPtr < endPtr) {\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\n           count++;\n        }\n\n        return count;\n    }\n\n    // @return entire rlp item byte length\n    function _itemLength(uint memPtr) private pure returns (uint) {\n        uint itemLen;\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START)\n            itemLen = 1;\n        \n        else if (byte0 < STRING_LONG_START)\n            itemLen = byte0 - STRING_SHORT_START + 1;\n\n        else if (byte0 < LIST_SHORT_START) {\n            assembly {\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n                memPtr := add(memPtr, 1) // skip over the first byte\n                \n                /* 32 byte word size */\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        else if (byte0 < LIST_LONG_START) {\n            itemLen = byte0 - LIST_SHORT_START + 1;\n        } \n\n        else {\n            assembly {\n                let byteLen := sub(byte0, 0xf7)\n                memPtr := add(memPtr, 1)\n\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n                itemLen := add(dataLen, add(byteLen, 1))\n            }\n        }\n\n        return itemLen;\n    }\n\n    // @return number of bytes until the data\n    function _payloadOffset(uint memPtr) private pure returns (uint) {\n        uint byte0;\n        assembly {\n            byte0 := byte(0, mload(memPtr))\n        }\n\n        if (byte0 < STRING_SHORT_START) \n            return 0;\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\n            return 1;\n        else if (byte0 < LIST_SHORT_START)  // being explicit\n            return byte0 - (STRING_LONG_START - 1) + 1;\n        else\n            return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n\n    /*\n    * @param src Pointer to source\n    * @param dest Pointer to destination\n    * @param len Amount of memory to copy from the source\n    */\n    function copy(uint src, uint dest, uint len) private pure {\n        if (len == 0) return;\n\n        // copy as many word sizes as possible\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += WORD_SIZE;\n            dest += WORD_SIZE;\n        }\n\n        if (len > 0) {\n            // left over bytes. Mask is used to remove unwanted bytes from the word\n            uint mask = 256 ** (WORD_SIZE - len) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask)) // zero out src\n                let destpart := and(mload(dest), mask) // retrieve the bytes\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}